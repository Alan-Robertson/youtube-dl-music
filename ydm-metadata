#!/usr/bin/env python3
"""
This script adds metadata from the MusicBrainz and Discogs databases
for 'Artist - Title.mp3' and 'Artist - Title.m4a' files. If the file is not
AAC/MP4, the ID3v2.4 header is used to write metadata. Otherwise, special
MP4 metadata specification is used. Requires musicbrainzngs.

Todo
----
1. Maybe pull cover art from Discogs master-release info if it is available; Discogs
   could be generally more reliable there. But still use MusicBrainz for searching because impossible
   to search for recording and artist at same time with current Discogs API.
2. Try to get rid of the current empirical steps, like genre-tag filtering (usually to
   fix the weird MusicBrainz results) and artist name verification. For the former, could just get
   Discogs genre from **every available Master release** from the groups of recordings.
3. Fix automatic album selection to ensure album always uses Latin characters,
   i.e. no Japanese text and whatnot!
"""
# Tagging tools
# PE1 is artist, CON is genre, ALB is album name, YER is year of recording,
# ORY is original release year, IT2 is song title, APIC is artwork, and COMM is comment
from mutagen.mp4 import MP4, MP4Cover, MP4StreamInfoError
from mutagen.id3 import ID3, ID3NoHeaderError, TIT2, TPE1, TCON, TALB, TOAL, TDRC, TDOR, TDRL, APIC, COMM
# Argument parsing
import argparse
# Database APIs
import discogs_client
import musicbrainzngs as mb
from musicbrainzngs.musicbrainz import ResponseError
# For getting discogs stuff
from bs4 import BeautifulSoup # distills HTML code into human-readable stuff
import requests
# For processing image
from io import BytesIO
from PIL import Image # check out image size with this stuff
# For memory
import pandas as pd
# Miscellaneous
import re # needed later
import sys
import os
import unidecode as ud # converting accents to normal characters

#------------------------------------------------------------------------------#
# Configure
#------------------------------------------------------------------------------#
# File names
storage = os.path.dirname(os.path.realpath(__file__))
config = f"{storage}/config"
choices = f"{storage}/choices"
genrelist = f"{storage}/genrelist"

# Read valid genres
# Ignore the non-musical specifications, e.g. "Soundtrack", and a couple others
bad_genres = (
    'Soundtrack','Score','Special Effects','Movie Effects', # movie stuff
    'Contemporary','Easy Listening','Early','Political', # not useful
    )
with open(genrelist,"r") as f:
    discogs_genres = [s.strip() for s in f.readlines()] # strip removes newline chars
discogs_genres = [genre for genre in discogs_genres if genre not in bad_genres] # filter

# Read config file
if not os.path.exists(config):
    raise IOError("To get metadata, you must add fields to a config file called \"config\" in the project directory.")
with open(config, "r") as file:
    config = file.readlines()
config = [l.strip().replace("\"",'').replace("'",'') for l in config]
config = [l.split('=') for l in config if l!=''] # tuples of pairs
if not all(len(t)==2 for t in config):
    raise ValueError("Formatting error in config file. Lines must look like \"key = value\".")
config = {t[0].strip(): t[1].strip() for t in config} # to dictionary
if 'username' not in config or 'password' not in config:
    raise ValueError("Cannot find MusicBrainz keys in config file. Add the lines \"username = <username>\" and "
            "\"password = <password>\" to enable metadata tagging.")
if 'token' not in config:
    raise ValueError("Cannot find Discogs token in config file. Add the line \"token = <token>\" "
            "to enable metadata tagging.")
# Config MusicBrainz
mb.auth(config['username'], config['password'])
mb.set_useragent('Self', 'NA', contact=config.get('contact',''))
# Config Discogs
client = discogs_client.Client('Personal', user_token=config['token'])
# Preferred release group types for retrieving album name and artwork
# Lists of items indicate no preference
type_prefs_grouped = ({'Album','Single'},{'EP'},{'Compilation','Other','Soundtrack','NA'},{'Live'})
# Preferred media type for album name and artwork
media_pref = ('digital','usb','cd','dvd','cassette','vinyl','xxxxx','other')
# Valid countries and regions for album name and artwork, includes global designations
anglo_countries = ('NA','XU','XW','XE','US','GB','AU','CA','IE','other')
# anglo_countries = ('XW','XE','US','GB','AU','CA','IE')
# anglo_countries = ('US','GB','CA','AU','IE','JP','XE','XU','XW','NA')

#------------------------------------------------------------------------------#
# Helper functions
#------------------------------------------------------------------------------#
# Request user yes/no input and parses
def confirm():
    if not options['c']:
        return True
    while True: # just keep going until get valid one
        response = input('Confirm (y/n)?')
        if len(response)>0:
            if response[0].lower()=='n':
                return False # continue?
            elif response[0].lower()=='y':
                return True # continue?
        print('Invalid choice.') 
# Get URL data from HTML lines
# Each page.find moves the "reader/parser" farther down the object
def find_urls(page):
    start_link = page.find("a href")
    if start_link == -1:
        return None, 0
    start_quote = page.find('"', start_link)
    end_quote = page.find('"', start_quote+1)
    url = page[start_quote+1:end_quote]
    return url, end_quote
# Standardize text by eliminating all non-alphanumeric characters,
# parentheticals, and accents
def words(string):
    iwords = []
    ignore_words = ['part', 'the', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix']
    for istring in string.split('/'):
        istring = ud.unidecode(string) # get plain ASCII letters from accents
        istring = re.sub("&", " and ", istring) # no symbols
        istring = re.sub(r"\(.*\)", "", istring) # delete stuff in parentheses
        istring = re.sub(r"“.*”", "", istring) # delete stuff in quotes
        istring = re.sub(r"[^\w\s]", " ", istring) # delete punctuation
        iwords += [[w for w in istring.lower().split()
            if w not in ignore_words and len(w)>1]] # just add the words; the accounts for e.g. The Stooges
        # istring = re.sub(r"“(.*)”",r"\1",istring) # remove quotes
        # istring = re.sub(r"\((.*)\)",r"\1",istring) # remove parentheses
    return iwords
# Parse user response
def parse(choices, N): # N is max possible number
    if len(choices)==0:
        print('Invalid choice.')
        return None
    if choices=='0':
        choices = [c+1 for c in range(N)]
    else:
        try: choices = [int(c) for c in choices.split(',')]
        except TypeError:
            print('Input must be integer.')
            return None
    # Make sure they are all in valid range
    if any(c<0 for c in choices):
        print('Integer must be >=0.')
        return None
    if any(c>N for c in choices):
        print(f'Integer must be <={N}.')
        return None
    return choices

#------------------------------------------------------------------------------#
# Function to get recording data from just the simple artist-recording names
#------------------------------------------------------------------------------#
def guess_recordings(artist, recording): #artistnames, artistids):
    """Searches MusicBrainz for the artist and recordings corresponding to input.
    Tries to do this intelligently, and account for some rare special cases."""
    # Premature track and artist filtering, so the "strict search" will give
    # reasonable results.
    artist = artist.split('ft.')[0]             # get first artist in name; they will be credited separately
    recording = recording.split('+')[0]         # get first song in combo
    recording = re.sub(r"\(.*\)"," ",recording) # delete stuff in parentheses
    recording = " ".join(recording.split())     # single spaces only

    # (Step 0) Search the database with a strict search, results should be pretty darn good
    # Results will have list of artist dictionaries under the "artist-credit" fields
    # For some reason each artist dictionary is embedded in a singleton dictionary with key "artist"
    offset = 0         # start at 0 offset
    round2 = False # have we tried another search?
    recordings = []    # put recordings here
    new_recordings = [None]
    while len(new_recordings)>0:
        # Get recordings; can only run through 100 at a time at most, so make sure to get all
        if offset>0:
            print(f'Found {offset} recordings...') # message
        if offset % 100 != 0:
            break # makes things a bit quicker
        new_recordings = mb.search_recordings(recording, artist=artist,
                strict=True, limit=100, offset=offset)['recording-list']
        if offset==0 and len(new_recordings)==0:
            # Typo in name; try to repair! Then re-run loop with new name.
            if round2:
                raise ValueError("No recordings found. You might have a typo in your artist or title name. "
                    "Tried to repair typo with non-strict search, with no luck.")
            round2 = True
            new_recordings = [None] # to reset list
            try: # try the search again
                new_recording = mb.search_recordings(recording, artist=artist,
                        strict=False, limit=50)['recording-list'][0]
                recording, artist = new_recording['title'], new_recording['artist-credit'][0]['artist']['name']
                print(f"Warning: Search failed. Will try again with artist \"{artist}\" and recording name \"{recording}.\"")
            except (IndexError, KeyError): # no results or something
                raise ValueError("No recordings found. You might have a typo in your artist or title name. Tried to repair typo with non-strict search, with no luck.")
        else:
            # Add to list of names
            if round2 and offset==0: # only after we were successful
                print(f"Warning: Probable typo in your filename; should be should be \"{artist} - {recording}.\"")
            recordings.extend(new_recordings)
            offset += len(new_recordings)
    # Lists
    if len(recordings)==0:
        raise ValueError("No recordings found. You might have a typo in your title or artist name.")
    rec_artists = [irecording['artist-credit'][0] for irecording in recordings
            if len(irecording.get('artist-credit',[]))>0] # verify length is non-zero
    rec_artists = [rec_artist.get('artist',{}) for rec_artist in rec_artists 
            if type(rec_artist) is dict] # now extract dictionaries with actual information
    rec_artists_ids = [rec_artist.get('id','') for rec_artist in rec_artists]

    # (Step 1) Perform clever filter to unique artists associated with the recordings
    # This is generally rare with strict search, but we want to be extra careful
    uq_artist_ids = set() # initialize empty set
    uq_artists = [rec_artist for rec_artist in rec_artists
            if rec_artist.get('id','') not in uq_artist_ids # check if already recorded this one
            and not uq_artist_ids.add(rec_artist.get('id',''))] # if not, add to set during comprehension
    if len(uq_artists)==0:
        raise ValueError("No recordings found. You might have a typo in your artist name.")
    if len(uq_artists)>1:
        # There is more than one unique artist in the list; we must pick one
        # Load the config file, and see if a previous response is in there
        for i,uq_artist in enumerate(uq_artists): # simple message
            print(f"{i+1:d}: {uq_artist.get('name','')} "\
                    f"({uq_artist.get('disambiguation','')})".split('()')[0])
        try: df = pd.read_csv(choices, index_col=0, header=0, dtype=str)
        except FileNotFoundError:
            df = pd.DataFrame(index=[], columns=['choice'])
        # Requires new user response
        if not options['f'] and artist in df.index.values: # load previous user response
            ids = df.loc[artist].values[0].split(',') # list of ids user chose
            response = [c+1 for c,uq_artist in enumerate(uq_artists) if uq_artist.get('id','') in ids]
            print(f'Loaded previous response: {",".join(str(c) for c in response)}.') # the last choices
        # Get and save user response
        else:
            response = None # initialize with this
            while response is None: # if None there was error, and loop will repeat
                response = input('Which artist number(s) should we use (enter 0 for all)?')
                response = parse(response, len(uq_artists)) # returns None on error
            ids = ','.join(uq_artists[c-1].get('id','') for c in response)
            df.loc[artist] = ids # add ids to dataframe
            df.to_csv()
        recordings = [irecording for irecording,recartistid in zip(recordings,rec_artists_ids)
            if recartistid in ids] # make sure they are in user-selected choice
    else:
        # Don't need a list of possible ids; just use the only one left
        recordings = [irecording for irecording,recartistid in zip(recordings,rec_artists_ids)
            if recartistid==uq_artists[0].get('id','')] # make sure they are in user-selected choice

    # (Step 2) Filter out bad/unwanted recordings
    # Translate recordings, so no rejection due to capitalization/punctuation
    if options['s']:
        if options['v']:
            rec_titles = {irecording.get('title','') for irecording in recordings}
            print('Discovered track names:',*rec_titles,sep='\n')
        recordings = [irecording for irecording in recordings if # check equality of word-lists
            any(x==y for x,y in zip(words(recording),words(irecording.get('title',''))))]
        if options['v']:
            rec_titles = {irecording.get('title','') for irecording in recordings}
            print('Filtered track names:',*rec_titles,sep='\n')
    if len(recordings)==0:
        raise ValueError("No recordings found. You might have a typo in your title name.")

    # Return results
    return artist, recordings

#------------------------------------------------------------------------------#
# Function to guess album from list of recording dictionaries
#------------------------------------------------------------------------------#
def guess_album(recordings):
    """Guesses album group from input info. Returns a dictionary of metadata information
    including year, album title, image, and genres."""
    # Start with simple list of releases and recordings, as two separate groups
    # Note the recording list has repeated items to match placement of corresponding releases
    releases = [release for recording in recordings for release in recording.get('release-list',[])]
    recordings = [recording for recording in recordings for release in recording.get('release-list',[])]
        # keep the recordings in-tact

    # Get families of releases belonging to release groups
    # This stuff is complicated and I don't want to look at it again
    groups = []
    duplicates = 0 # will record number of duplicates removed
    rgroup_ids = [release.get('release-group',{}).get('id','') for release in releases] # 1:1 correspondance with above
    unique_idxs = [rgroup_ids.index(r) for r in set(rgroup_ids)] # unique indices
    for uidx in unique_idxs: # will iterate through unique releases
        # Get release group dict, and add to it the releases we've already 
        # loaded as a list under the 'releases' keyword
        group = releases[uidx].get('release-group',{})
        greleases = [release for release,rgroupid in zip(releases,rgroup_ids) if rgroupid==rgroup_ids[uidx]]
        grecordings = [recording for recording,rgroupid in zip(recordings,rgroup_ids) if rgroupid==rgroup_ids[uidx]]
        # Also make sure the release list is unique (potential for overlap in release names, if
        # multiple recording ids were accepted)
        grelease_ids = [grelease.get('id','') for grelease in greleases]
        gunique_idxs = [grelease_ids.index(g) for g in set(grelease_ids)]
        greleases = [grelease for idx,grelease in enumerate(greleases) if idx in gunique_idxs]
        if len(greleases)<len(grelease_ids): # black magic
            duplicates += len(grelease_ids)-len(greleases)
        # Pop the release-group dictionary from the release list
        # Then save the releases/recordings corresponding to this group
        for grelease in greleases:
            grelease.pop('release-group')
        group['releases'] = greleases
        group['recordings'] = grecordings
        groups.append(group)
    # Message
    print(f"Consolidated {len(releases):d} releases into {len(groups)} release groups ({duplicates:d} duplicates removed).")

    # Add new information to the original release-group dictionaries
    # This information will be used to sort albums by a hieararchy of preferred characteristics
    for group in groups:
        group['count'] = len(group['releases'])
        group['years'] = [int(release.get('date','9999')[:4]) for release in group['releases'] if release.get('date','9999')] # if non-empty
        group['years'] = [*{year for year in group['years'] if 1900<year<2100}]
        group['years'] = [9999] if len(group['years'])==0 else group['years']
        group['titles'] = [*{release.get('title','') for release in group['releases']}]

    # 1) Get the recording year as simply the earliest date-release amongst releases in the release group
    # Will get the title in the loop below, and same for genres
    year = str(min(min(group['years']) for group in groups))
    year = '' if year=='9999' else year
    # Get some helper info: need to sort groups by earliest 'official' release year among its release
    # members, and by its type (album vs. single, etc.)
    genres = [] # start empty
    title = None # initialize
    image = None # initialize
    metadata = None # initialize
    for itype,type_prefs in enumerate(type_prefs_grouped):
        print(f"Trying album types: {', '.join(type_prefs)}.")
        for type_ in type_prefs:
            groupsA = [group for group in groups if group.get('type','NA')==type_]
            for firstyear in sorted(set(min(group['years']) for group in groupsA)): # note min([None])==None
                groupsB = [group for group in groupsA if min(group['years'])==firstyear]
                # Sort by number of releases in group
                for count in sorted(set(group['count'] for group in groupsB), reverse=True):
                    groupsC = [group for group in groupsB if group['count']==count]
                    for group in groupsC:
                        # 2) Get the title; choose as the title of a release in the PREFERRED
                        # group for getting artwork; not the first one that actually has artwork
                        if title is None or image is None:
                            title = min((title for title in group['titles'] if
                                group.get('country','NA') in anglo_countries), key=len)
                        # 3) Get the genres, if haven't found them yet
                        # Will prioritize Discogs genres but use MusicBrainz as backup
                        # * Discogs genres are from the Master release, not specific to song
                        # * MusicBrainz genres are not from Master release, but instead from
                        #   taglist in every recording belonging to the Master release
                        if len(genres)==0:
                            added = set() # start empty set
                            dgenres = [genre for genre in genres_discogs(group['id'])
                                if genre not in added and not added.add(genre)] # unique, preserve order
                            mgenres = [genre for genre in genres_musicbrainz(group['recordings'])
                                if genre not in added and not added.add(genre)] # still preserve order
                            # Limit results: match number of MusicBrainz with number Discogs, say
                            if len(dgenres)==0:
                                limit = 3
                                genres = mgenres[:limit]
                            else:
                                genres = dgenres + mgenres[:len(dgenres)]
                        # Consolidate info so far
                        metadata = {'title':title, 'year':year, 'genres':genres, 'image':None}
                        # 4) Next the album artwork
                        # First confirm user wants to use this album for artwork
                        years = [year for year in group['years'] if year!=9999]
                        years = [-1] if len(years)==0 else years
                        if options['v']:
                            print(f"Release-group candidate: name(s) '{', '.join(group['titles'])}', type '{type_}', "
                                  f"count {group['count']}, earliest year '{min(years)}', latest year '{max(years)}'.")
                        if not confirm():
                            continue
                        image = guess_artwork(group['releases'])
                        if image is None:
                            if options['v']:
                                print("No album artwork available for this group.")
                            continue
                        else:
                            metadata.update({'image':image})
                            return metadata

    # Exit from here if failed to get artwork every time
    if options['v']:
        print("Warning: Failed to find album artwork.")
    if metadata is None:
        raise ValueError("No metadata to write.")
    return metadata

#------------------------------------------------------------------------------#
# Function to get "best" artwork from a release group
#------------------------------------------------------------------------------#
def guess_artwork(releases):
    """Gets album artwork, preferring anglophone countries."""
    # First, go by release medium
    years = [int(release.get('date','0001')[:4]) for release in releases if release.get('date','0001')]
    filter_known = [False for release in releases] # want to catch any unknown media
    for m,medium in enumerate(media_pref):
        if medium=='other': # we are at the end; see if any media were left
            filter_ = [not known for known in filter_known] # iterate over what's left
        else: # filter, and add known media to lsit
            filter_ = [any(medium in _.get('format','xxxxx').lower() for _ in release.get('medium-list',[{}]))
                for release in releases] # last one is unknown
            filter_known = [f1 or f2 for f1,f2 in zip(filter_,filter_known)]
        releasesA = [r for f,r in zip(filter_,releases) if f]
        yearsA = [y for f,y in zip(filter_,years) if f]
        for year in sorted(set(yearsA), reverse=True):
            releasesB = [r for r,y in zip(releasesA,yearsA) if y==year]
            for country in anglo_countries:
                # Also try non-anglo countries (sometimes only one available)
                if country=='other':
                    releasesC = [r for r in releasesB if r.get('country','NA') not in anglo_countries]
                else:
                    releasesC = [r for r in releasesB if r.get('country','NA')==country]
                # Try to return image art; remaining releases, choose order at random
                for release in releasesC:
                    # User input
                    rmedia = [m.get('format','') for m in release.get('medium-list',[{}])]
                    rcountry, rtitle = release.get('country',''), release.get('title','')
                    if options['v']:
                        print(f"Release candidate: name '{rtitle}', media '{', '.join(rmedia)}', country '{rcountry}', year '{year}'.")
                    if not confirm():
                        continue
                    # Pull artwork
                    # This is a slow step, so make sure to print message
                    try:
                        print('Trying album...')
                        data = mb.get_image_front(release.get('id',''))
                    except ResponseError:
                        continue
                    # Manipulate
                    image = Image.open(BytesIO(data))
                    if options['v']:
                        print(f"Image shape: {image.size[0]} x {image.size[1]}. Warping to square if not equal.")
                    if image.size[0]!=image.size[1]:
                        data = BytesIO()
                        sqsize = min(image.size)
                        image = image.resize((sqsize,sqsize), Image.ANTIALIAS)
                        image.save(data, format='JPEG')
                        data = data.getvalue()
                    return data

#------------------------------------------------------------------------------#
# Functions to get genres from both MusicBrainz and Discogs
#------------------------------------------------------------------------------#
def genres_discogs(rgid):
    """Gets the discogs page linked to a release group, and pulls the genre info
    or album artwork from there."""
    # Get the MusicBrainz URL from the releasegroup id
    url = f"https://musicbrainz.org/release-group/{rgid}"
    try: content = requests.get(url).content
    except ConnectionError:
        raise ValueError('MusicBrainz release-group ID appears to be invalid.')

    page = BeautifulSoup(content, 'lxml').decode() # converts to string
    # Parse HTMl page to get the discogs id
    # From: https://stackoverflow.com/questions/15517483/how-to-extract-urls-from-an-html-page-in-python
    urls = []
    url = True # fill initial case
    while url: # while non-empty
        url, n = find_urls(page)
        page = page[n:]
        if url: urls.append(url)

    # Get discogs URL (set comprehension, because want unique result)
    # And parse out the discogs release id
    urls = [*{url.rstrip('/') for url in urls if 'discogs' in url}]
    if len(urls)==0:
        if options['v']:
            print('Warning: No Discogs genres found, could not find URL on MusicBrainz page.')
        return []
    if len(urls)>1:
        if options['v']:
            print(f"Warning: No Discogs genres found, ambiguous number of URL candidates on MusicBrainz page: {', '.join(urls)}.")
        return []
    master = os.path.basename(urls[0]) # because it is the last part after slash
    try:
        master = int(master)
    except TypeError:
        if options['v']:
            print('Warning: No Discogs genres found, could not parse the URL found on MusicBrainz page.')
        return []
    # Finally, call discogs by release-group id
    data = client.master(master) # this function just looks up id, returns stuff
    styles = data.fetch('styles') # sometimes doesn't return everything in data dict; maybe is not
    genres = data.fetch('genres') # add genres
        # supposed to be accessed by users; only use fetch from now on
    if styles is None: styles = []
    if genres is None: genres = []
    genres = genres+styles
    if len(genres)==0:
        if options['v']:
            print("Warning: No Discogs genres found, none listed under the 'master' release.")
        return []
    if 'Funk / Soul' in genres: # special filter
        remove = genres.index('Funk / Soul')
        genres = genres[:remove] + ['Funk','Soul'] + genres[remove+1:]
            # add these individually, and preserve location in original list
    added = set()
    genres = [genre for genre in genres if genre in discogs_genres
            and not (genre in added or added.add(genre))]
    if len(genres)==0:
        if options['v']:
            print("Warning: No Discogs genres found, labels were too vague, e.g. \"Rock\".")
        return []
    if options['v']:
        print(f"Discogs genres for writing: {', '.join(genres)}.")
    return genres

def genres_musicbrainz(recordings):
    """Gets the genres from the MusicBrainz tag-list associated with a list
    of recordings. Ouputs count-genres lists."""
    # First get list of tags, and create list of genre-count pairs
    # Add counts for tags that are duplicated
    tags = {}
    for recording in recordings:
        tagl = recording.get('tag-list',{})
        for tagd in tagl: # dictionaries
            if tagd['name'] not in tags:
                tags[tagd['name']] = int(tagd['count'])
            else:
                tags[tagd['name']] += int(tagd['count'])
    genres = sorted(list(tags.items()), key=lambda x: x[1], reverse=True) # (genre,count) tuples
    genres = [[*genre] for genre in genres] # convert to lists
    if len(genres)==0:
        if options['v']:
            print("Warning: No MusicBrainz genres found, taglist was empty.")
        return []
    # Echo message
    igenres, counts = zip(*genres) # see: https://stackoverflow.com/a/44157777/4970632
    genres_announce = [f"{genre} ({count:d})" for genre,count in zip(igenres,counts) if count>0]
    if options['v']:
        print(f"MusicBrainz taglist: {', '.join(genres_announce)}.")

    # Split up strings suspected to contain multiple genres
    has_split, genres_split = [], []
    for g,genre in enumerate(genres):
        split = []
        if '/' in genre[0]:
            split = genre[0].split('/')
        elif ';' in genre[0]:
            split = genre[0].split(';')
        if split:
            has_split.append(g)
            for genre_new in split:
                genres_split.append([genre_new,genre[1]])
    # Now ignore the genre-names with slashes in them, and re-combine
    genres = [genre for g,genre in enumerate(genres) if g not in has_split]
    genres = genres + genres_split

    # Run basic translations; maybe a tag is something we want, just under
    # slightly different name than Discogs conventions
    genres_new = []
    for g,genre in enumerate(genres):
        # First split up the string into "words"
        name, count = genre
        name = name.lower() # ensure lower-case
        name = name.replace(' and ',' & ') # discogs uses ampersand
        name = name.replace('&',' & ') # make sure separated by space
        name = name.replace('-',' ')
        added, words = set(), name.split() # split by spaces
        words = [w for w in words if not (w in added or added.add(w))] # added.add returns None
        if len(words)==0:
            genres_new.append(['', 0])
            continue
        # Handle abbreviations and style variations
        if words[0]=='alt': # here Discogs does not use abbreviation
            words[0] = 'alternative'
        if words[0]=='progressive': # here Discogs does use abbreviation
            words[0] = 'prog'
        if words[0]=='rock' and words[-1]=='roll': # correct e.g. rock n' roll
            words = ['rock', '&', 'roll']
        if 'rnb' in words or (words[0]=='r' and words[-1]=='b'): # correct e.g. r n' b
            words = ['rhythm', '&', 'blues']
        if 'aor' in words: # AOR == album oriented rock
            words = ['album', 'rock']
        # Break up or join words to match Discogs convention
        if 'powerpop' in words: # powerpop == power pop
            words = ['power', 'pop']
        if 'synthpop' in words: # powerpop == power pop
            words = ['synth', 'pop']
        if 'classic' in words and 'rock' in words: # sometimes get <something> classic rock
            words = ['classic','rock']
        if 'avant' in words or 'garde' in words: # avante-garde/avante garde == Avantegarde
            words = ['avantgarde']
        # Word order, e.g. rock pop --> pop rock
        if words[0]=='rock' and len(words)>1 and words[1]!='&':
            words = reversed(words)
        name = ' '.join(words) # uniform spacing
        genres_new.append([name, count])
    genres = genres_new

    # If genre-name is found twice, add their counts
    genrecount = {}
    for genre in genres:
        try: genrecount[genre[0]] += genre[1]
        except KeyError:
            genrecount[genre[0]] = genre[1]
    genres = [[genre,count] for genre,count in genrecount.items()] # back to list of lists
    genres = sorted(genres, key=lambda x: x[1], reverse=True)

    # Filter the genre list by Discogs genres: compare where alphanumeric characters
    # match a Discogs style, then use the exact Discogs convention for punctuation
    # and capitalization
    standardize = lambda string: ' '.join(re.sub('\W',' ',string).split()).lower() # non-alphenumeric char == \W
    discogs_std = [standardize(g) for g in discogs_genres] # standard names for comparison
    genres = [(discogs_genres[discogs_std.index(standardize(genre[0]))], genre[1])
            for genre in genres if standardize(genre[0]) in discogs_std
            and genre[1]>0] # make sure at least one "count" is present
    # If genre in added, 2nd statement is not called, but that's ok because
    # we don't need to re-add it to the set
    added = set() # start an empty set
    genres = [genre for genre in genres if not (genre[0] in added or added.add(genre[0]))]

    # Now return, and echo message
    # Preserved counts until this point, so message is more informative
    if len(genres)>0:
        genres, counts = zip(*genres) # see: https://stackoverflow.com/a/44157777/4970632
        genres_announce = [f"{genre} ({count:d})" for genre,count in zip(genres,counts)]
        if options['v']:
            print(f"MusicBrainz genres for writing: {', '.join(genres_announce)}.")
        return [*genres]
    else:
        if options['v']:
            print("Warning: No MusicBrainz genres found, couldn't find any useful recording tags.")
        return []

#------------------------------------------------------------------------------#
# Execute when invoked from commandline
#------------------------------------------------------------------------------#
if __name__ == "__main__":
    # Parse all command-line arguments
    # TODO: Use argparser?
    url = '' # by default, write nothing
    options = 'scfv'
    options = {option: False for option in options} # the default settings
    filepaths = []
    for arg in sys.argv[1:]:
        if arg[:1]=='-' and len(arg)>1:
            flag = arg[1:2]
            if flag=='u': # better than trying implicit search
                url = arg[3:] # skip '-u='
                if len(url)==1:
                    raise ValueError("Invalid url argument: {arg}")
            elif flag in options: # a True/False flag
                options[flag] = True
            else:
                raise ValueError("Invalid argument: {arg}")
        else:
            filepaths.append(arg)

    for filepath in filepaths:
        # Check existence of files and infer artist/track information
        if not os.path.exists(filepath):
            raise ValueError(f"Could not find file {filepath}.")
        filename = os.path.splitext(os.path.basename(filepath))[0].split(' - ')
        if len(filename)!=2:
            raise ValueError("Filename is not in the '<artist> - <title>' format.")
        artist, recording = filename # convert to artist and track

        # Open file, for different types
        # Currently have compatibility with MP4 and ID3 tags
        try: # read AAC info
            id3 = False # aac
            tags = MP4(filepath)
        except MP4StreamInfoError:
            id3 = True # mp3
            try: # check header presence
                tags = ID3(filepath)
            except ID3NoHeaderError:
                raise ValueError("Format may be incorrect.")

        # Call functions and apply metadata
        if options['v']:
            print(f"Retrieving metadata for \"{artist} - {recording}\".")
        artist, recordings = guess_recordings(artist, recording) # pull just the recordings
        recording = recordings[0]['title'] # just use the first one
        albumprops = guess_album(recordings) # pull album year, artwork, and genres
        if albumprops is None:
            raise ValueError("Found no metadata.")

        # Edit the ID3 header, if file has one
        message = f"{albumprops['title']} ({albumprops['year']}"
        if len(albumprops['genres'])==0:
            message += ').'
        else:
            message += ('; genres ' + ', '.join(albumprops['genres']) + ').')
        print(message)
        if id3:
            # Below are ID3v2, not ID3v2.4 (default format of mutagen, and modern version)
            tags.delete(filepath) # delete old data, if we downloaded from somewhere; want to assigne my better data
            # General stuff
            tags["TPE1"] = TPE1(text=artist)
            tags["TIT2"] = TIT2(text=recording) # just track name
            tags["COMM"] = COMM(text=url, lang="eng", desc="URL")
            # Album stuff
            # NOTE: Also have TYER, TORY, TDAT, and TRDA for times
            tags["TDOR"] = TDOR(text=albumprops['year']) # original release time
            tags["TDRC"] = TDRC(text=albumprops['year']) # recording time
            tags["TDRL"] = TDRL(text=albumprops['year']) # release time
            tags["TALB"] = TALB(text=albumprops['title']) # album
            tags["TOAL"] = TOAL(text=albumprops['title']) # original album
            # Artwork
            if albumprops['image'] is not None:
                tags["APIC"] = APIC(data=albumprops['image'])
            if albumprops['genres'] is not None:
                tags["TCON"] = TCON(text=albumprops['genres'][0], genres=albumprops['genres'])
            tags.save(filepath) # supply path, in case we are creating ID3 header for first time

        # Or just edit as an AAC file
        else:
            # General stuff
            tags["\xa9ART"] = [artist] # artist; includes whether "The" is in front, best punctuation, etc.
            tags["\xa9nam"] = [recording] # track name
            tags["\xa9cmt"] = [url] # embed URL as comment
            # Album stuff
            tags["\xa9day"] = [albumprops['year']]
            tags["\xa9alb"] = [albumprops['title']] # album, from lookup
            if albumprops['image'] is not None:
                tags["covr"] = [MP4Cover(albumprops['image'], imageformat=MP4Cover.FORMAT_JPEG)]
            if albumprops['genres'] is not None:
                tags["\xa9gen"] = [*albumprops['genres']] # genres
            tags.save()

