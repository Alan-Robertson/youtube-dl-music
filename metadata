#!/usr/bin/env python
"""
This script adds metadata from the MusicBrainz database based on the <artist> - <title> 
from so-formatted audio files. If file is not AAC/MP4 (iTunes default), will use ID3v2.4 header; 
otherwise, will use special MP4 metadata assignment. Requires musicbrainzngs (use pip install).
"""
# TODO:
# 1) Maybe pull cover art from Discogs master-release info if it is available; Discogs
# could be generally more reliable there. But still use MusicBrainz for searching because impossible
# to search for recording and artist at same time with current Discogs API.
# 2) Try to get rid of the current empirical steps, like genre-tag filtering (usually to
# fix the weird MusicBrainz results) and artist name verification. For the former, could just get
# Discogs genre from **every available Master release** from the groups of recordings.

# Tagging tools
from mutagen.mp4 import MP4, MP4Cover, MP4StreamInfoError
from mutagen.id3 import ID3, ID3NoHeaderError, TIT2, TPE1, TCON, TALB, TOAL, TDRC, TDOR, TDRL, APIC, COMM
    # PE1 is artist, CON is genre, ALB is album name, YER is year of recording,
    # ORY is original release year, IT2 is song title, APIC is artwork, and COMM is comment
# Database APIs
import discogs_client
import musicbrainzngs as mb
from musicbrainzngs.musicbrainz import ResponseError
# For getting discogs stuff
from bs4 import BeautifulSoup # distills HTML code into human-readable stuff
import requests
# For processing image
from io import BytesIO
from PIL import Image # check out image size with this stuff
# For memory
import pandas as pd
# Miscellaneous
import re # needed later
import sys
import os
from enchant import Dict
import unidecode as ud # converting accents to normal characters
from collections import defaultdict
# Dictionary setup
dictionary = Dict('en_US')
for exception in ['indie','fi','&']: # as in lo-fi, hi-fi
    dictionary.add(exception) # not in dictionary, but we allow it
        # also need to add ampersand, because returns False

################################################################################
# Configure
################################################################################
# File names
storage = os.path.dirname(os.path.realpath(__file__))
config = f"{storage}/config"
metaconfig = f"{storage}/metaconfig"
metanoconfig = f"{storage}/metanoconfig"
# Read config file
if not os.path.exists(config):
    raise IOError("To get metadata, you must add fields to the config file.")
with open(config, "r") as file:
    config = file.readlines()
config = [l.strip().replace("\"",'').replace("'",'') for l in config]
config = [l.split('=') for l in config if l!=''] # tuples of pairs
if not all(len(t)==2 for t in config):
    raise ValueError("Formatting error in config file. Lines must look like \"key = value\".")
config = {t[0].strip(): t[1].strip() for t in config} # to dictionary
if 'username' not in config or 'password' not in config:
    raise ValueError("Cannot find MusicBrainz keys in config file. Add the lines \"username = <username>\" and "
            "\"password = <password>\" to enable metadata tagging.")
if 'token' not in config:
    raise ValueError("Cannot find Discogs token in config file. Add the line \"token = <token>\" "
            "to enable metadata tagging.")
# Config MusicBrainz
mb.auth(config['username'], config['password'])
mb.set_useragent('Self', 'NA', contact=config.get('contact',''))
# Config Discogs
client = discogs_client.Client('Personal', user_token=config['token'])

################################################################################
# Helper functions
################################################################################
def yesno():
    # Requests user yes/no input and parses
    if options['noconfirm']:
        return True
    while True: # just keep going until get valid one
        response = input('Confirm (y/n)?')
        if len(response)>0:
            if response[0].lower()=='n':
                return False # continue?
            elif response[0].lower()=='y':
                return True # continue?
        print('Invalid choice.') 
def findurls(page):
    # Gets URL data from HTML lines
    # Each page.find moves the "reader/parser" farther down the object
    start_link = page.find("a href")
    if start_link == -1:
        return None, 0
    start_quote = page.find('"', start_link)
    end_quote = page.find('"', start_quote + 1)
    url = page[start_quote + 1: end_quote]
    return url, end_quote

################################################################################
# Function to get recording data from just the simple artist-recording names
################################################################################
def guess_recordings(artist, recording): #artistnames, artistids):
    """Searches MusicBrainz for the artist and recordings corresponding to input.
    Tries to do this intelligently, and account for some rare special cases."""
    def words(string):
        # Elminates all non-alphanumeric characters and parentheticals.
        # Allows for some limited exceptions
        iwords = []
        for istring in string.split('/'):
            istring = ud.unidecode(string) # get plain ASCII letters from accents
            istring = re.sub("\.","",istring) # e.g. S.O.S. goes to SOS
                # make sure to escape the '.'! that was a really dumb bug!
            istring = re.sub("&"," and ",istring) # standardize and symbols
            istring = re.sub(r"\(.*\)","",istring) # delete stuff in parentheses
            istring = re.sub(r"“.*”","",istring) # delete stuff in quotes
            istring = re.sub(r"[^\w\s]"," ",istring) # delete punctuation and stuff
            istring = istring.split(" and ")[0] # e.g. Joan Jett "and the Blackhearts"
            istring = istring.split(" ft ")[0] # e.g. Queen ft. David Bowie
            iwords += [[w for w in istring.lower().split()
                if w!='the' and len(w)>1]] # just add the words; the accounts for e.g. The Stooges
            # iwords += [[w for w in istring.lower().split()
            #     if w!='the' and len(w)>1]] # ignore single letters
        return iwords
    def parse(choices, N): # N is max possible number
        # Helper function for parsing user response
        if len(choices)==0:
            print('Invalid choice.')
            return None
        if choices=='0':
            choices = [c+1 for c in range(N)]
        else:
            try: choices = [int(c) for c in choices.split(',')]
            except TypeError:
                print('Input must be integer.')
                return None
        # Make sure they are all in valid range
        if any(c<0 for c in choices):
            print('Integer must be >=0.')
            return None
        if any(c>N for c in choices):
            print(f'Integer must be <={N}.')
            return None
        return choices
    def fixartist(artist):
        # Helper function that does a special artist-name translation
        # Different from the "words" function; that is meant to deal with punctuation
        # and accents and stuff. This is generally empirical.
        if '“' in artist and '”' in artist: # e.g. Haywire “Haywire Mac” McClintoc
            artist = artist.split('“')[0] + artist.split('”')[-1]
        if '∆' in artist: # stylized-name does not match database-name often
            artist = re.sub('[∆]','A',artist)
        if artist=='Chet Faker': # all releases are under this name in database
            artist = 'Nick Murphy'
        if artist=='Hall and Oates': # listed separately for some reason
            artist = 'Daryl Hall and John Oates'
        return artist
    # Premature track and artist filtering, so the "strict search" will give
    # reasonable results.
    artist = artist.split('ft.')[0] # get first artist in name; they will be credited separately
    recording = recording.split('+')[0] # get first song in combo
    recording = re.sub(r"\(.*\)"," ",recording) # delete stuff in parentheses
    recording = " ".join(recording.split()) # single spaces only
    # (Step 0) Search the database with a strict search, results should be pretty darn good
    # Results will have list of artist dictionaries under the "artist-credit" fields
    # For some reason each artist dictionary is embedded in a singleton dictionary with key "artist"
    # searchrecording = ' '.join([w for w in recording.split() # empirical hack; sometimes use wrong article/prep
    #     if w.lower() not in ['a','in','the','on','of','and','or','for']])
    # TODO: Apparently strict search actually requires EXACT NAME-MATCH of file but somehow
    # can accept some VARIATIONS in artist name (had some examples)... actually THAT'S WRONG because
    # search for "Mother" STILL TURNS UP those bad results. But "Born On A Bayou" failed vs. "The Bayou"
    # because CAN HAVE EXTRA WORDS, BUT MUST HAVE AT LEAST THE CORRECT ONES
    offset = 0 # start at 0 offset
    recordings = [] # put recordings here
    triedagain = False # have we tried another search?
    newrecordings = [None]
    while len(newrecordings)>0:
        # Get recordings; can only run through 100 at a time at most, so make sure to get all
        # newrecordings = mb.search_recordings(searchrecording, artist=artist,
        #         strict=True, limit=100, offset=offset)['recording-list']
        if offset>0: print(f'Found {offset} recordings...') # message
        if offset%100!=0: break # makes things a bit quicker
        newrecordings = mb.search_recordings(recording, artist=artist,
                strict=True, limit=100, offset=offset)['recording-list']
        # print([recording.get('title','') for recording in newrecordings])
        # print([recording.get('artist-credit',[{}])[0].get('artist',{}).get('name','') for recording in newrecordings])
        if offset==0 and len(newrecordings)==0:
            # Typo in name; try to repair! Then re-run loop with new name.
            if triedagain:
                raise ValueError("No recordings found. You might have a typo in your artist or title name. "
                    "Tried to repair typo with non-strict search, with no luck.")
            triedagain = True
            newrecordings = [None] # to reset list
            try: # try the search again
                # common = lambda l: max(set(l), key=l.count) # most common element
                # newrecording = mb.search_recordings(recording, artist=artist,
                #         strict=False, limit=50)['recording-list'] # new search
                # recording = print([r.get('title','') for r in newrecording]) # the recording
                # recording = common([r.get('title','') for r in newrecording]) # the recording
                # artist = [r.get('artist-credit',[{}])[0].get('artist',{}).get('name','') for r in newrecording] # get list of artists
                # print(artist)
                # artist = common([a for r,a in zip(newrecording,artist) if r.get('title','')==recording]) # the artist
                # print(recording,artist)
                newrecording = mb.search_recordings(recording, artist=artist,
                        strict=False, limit=50)['recording-list'][0]
                recording, artist = newrecording['title'], newrecording['artist-credit'][0]['artist']['name']
                print(f"Warning: Search failed. Will try again with artist \"{artist}\" and "
                        f"recording name \"{recording}.\"")
            except (IndexError, KeyError): # no results or something
                raise ValueError("No recordings found. You might have a typo in your artist or title name. "
                    "Tried to repair typo with non-strict search, with no luck.")
        else:
            # Add to list of names
            if triedagain and offset==0: # only after we were successful
                print(f"Warning: Probable typo in your filename; should be should be \"{artist} - {recording}.\"")
            recordings.extend(newrecordings)
            offset += len(newrecordings)
    if len(recordings)==0:
        raise ValueError("No recordings found. You might have a typo in your title or artist name.")
    recartists = [irecording['artist-credit'][0] for irecording in recordings
            if len(irecording.get('artist-credit',[]))>0] # verify length is non-zero
    recartists = [recartist.get('artist',{}) for recartist in recartists 
            if type(recartist) is dict] # now extract dictionaries with actual information
    recartistids = [recartist.get('id','') for recartist in recartists]
    # (Step 1) Perform clever filter to unique artists associated with the recordings
    # This is generally rare with strict search, but we want to be extra careful
    uqartistids = set() # initialize empty set
    uqartists = [recartist for recartist in recartists
            if recartist.get('id','') not in uqartistids # check if already recorded this one
            and not uqartistids.add(recartist.get('id',''))] # if not, add to set during comprehension
                # must be and statement, because if or, python will only execute the first one
    if options['filter']: # filter words
        # print([uqartist.get('name','') for uqartist in uqartists])
        uqartists = [uqartist for uqartist in uqartists if # check equality of word-lists
                words(fixartist(uqartist.get('name','')))==words(fixartist(artist))]
        # print([uqartist.get('name','') for uqartist in uqartists])
    if len(uqartists)==0:
        raise ValueError("No recordings found. You might have a typo in your artist name.")
    if len(uqartists)>1:
        # There is more than one unique artist in the list; we must pick one
        # Load the config file, and see if a previous response is in there
        for i,uqartist in enumerate(uqartists[:20]): # simple message
            print(f"{i+1:d}: {uqartist.get('name','')} "\
                    f"({uqartist.get('disambiguation','')})".split('()')[0])
        try: df = pd.read_csv(metaconfig, index_col=0, header=0, dtype=str)
        except FileNotFoundError:
            df = pd.DataFrame(index=[], columns=['choice'])
        if not options['noconfig'] and artist in df.index.values: # load previous user response
            ids = df.loc[artist].values[0].split(',') # list of ids user chose
            choices = [c+1 for c,uqartist in enumerate(uqartists) if uqartist.get('id','') in ids]
            print(f'Loaded previous response: {",".join(str(c) for c in choices)}.') # the last choices
        else: # get and save user response
            choices = None # initialize with this
            while choices is None: # if None there was error, and loop will repeat
                choices = input('Which artist number(s) should we use (enter 0 for all)?')
                choices = parse(choices, len(uqartists)) # returns None on error
            ids = ','.join(uqartists[c-1].get('id','') for c in choices)
            df.loc[artist] = ids # add ids to dataframe
            df.to_csv(metaconfig)
        recordings = [irecording for irecording,recartistid in zip(recordings,recartistids)
            if recartistid in ids] # make sure they are in user-selected choice
    else:
        # Don't need a list of possible ids; just use the only one left
        recordings = [irecording for irecording,recartistid in zip(recordings,recartistids)
            if recartistid==uqartists[0].get('id','')] # make sure they are in user-selected choice
    print(f'{len(recordings)} recordings with valid artist found.')
    # (Step 2) Filter out bad/unwanted recordings
    # Translate recordings, so no rejection due to capitalization/punctuation
    if options['filter']:
        if options['debug']:
            rectitles = {irecording.get('title','') for irecording in recordings}
            print('Discovered track names:',*rectitles,sep='\n')
        recordings = [irecording for irecording in recordings if # check equality of word-lists
            any(x==y for x,y in zip(words(recording),words(irecording.get('title',''))))]
        if options['debug']:
            rectitles = {irecording.get('title','') for irecording in recordings}
            print('Filtered track names:',*rectitles,sep='\n')
    print(f'{len(recordings)} recordings with valid title found.')
    if len(recordings)==0:
        raise ValueError("No recordings found. You might have a typo in your title name.")
    # Return results
    return artist, recordings

################################################################################
# Function to guess album from list of recording dictionaries
################################################################################
def guess_album(recordings):
    """Guesses album group from input info. Returns a dictionary of metadata information
    including year, album title, image, and genres."""
    # Start with simple list of releases and recordings, as two separate groups
    # Note the recording list has repeated items to match placement of corresponding releases
    releases = [release for recording in recordings for release in recording.get('release-list',[])]
    recordings = [recording for recording in recordings for release in recording.get('release-list',[])]
        # keep the recordings in-tact
    # Get families of releases belonging to release groups
    # This stuff is complicated and I don't want to look at it again
    groups = []
    duplicates = 0 # will record number of duplicates removed
    rgroupids = [release.get('release-group',{}).get('id','') for release in releases] # 1:1 correspondance with above
    uniqueidxs = [rgroupids.index(r) for r in set(rgroupids)] # unique indices
    for uidx in uniqueidxs: # will iterate through unique releases
        # Get release group dict, and add to it the releases we've already 
        # loaded as a list under the 'releases' keyword
        group = releases[uidx].get('release-group',{})
        greleases = [release for release,rgroupid in zip(releases,rgroupids) if rgroupid==rgroupids[uidx]]
        grecordings = [recording for recording,rgroupid in zip(recordings,rgroupids) if rgroupid==rgroupids[uidx]]
        # Also make sure the release list is unique (potential for overlap in release names, if
        # multiple recording ids were accepted)
        greleaseids = [grelease.get('id','') for grelease in greleases]
        guniqueidxs = [greleaseids.index(g) for g in set(greleaseids)]
        greleases = [grelease for idx,grelease in enumerate(greleases) if idx in guniqueidxs]
        if len(greleases)<len(greleaseids): # black magic
            duplicates += len(greleaseids)-len(greleases)
        # Pop the release-group dictionary from the release list
        # Then save the releases/recordings corresponding to this group
        for grelease in greleases:
            grelease.pop('release-group')
        group['releases'] = greleases
        group['recordings'] = grecordings
        groups.append(group)
    print(f"{len(releases):d} releases consolidated into {len(groups)} release groups ({duplicates:d} duplicates removed).")
    # Figure out the best title to write to file; generally the title corresponding to earliest
    # release year should be a good bet; don't get it from same release as album art (might be another language)
    titles = [release.get('title','') for group in groups for release in group['releases']]
    tyears = [int(release.get('date','9999')[:4]) for group in groups for release in group['releases']]
    ftitles = [title for y,title in zip(tyears,titles) if y>1900 and y<2100] # account for weird error sometimes
    ftyears = [y for y in tyears if y>1900 and y<2100] # account for weird error sometimes
    if len(ftitles)>0: # have more than one valid "year" info
        title = ftitles[ftyears.index(min(ftyears))] # earliest year
        year = str(min(ftyears)) # minimum year
    elif len(titles)>0: # can pick shortest one
        title = min(titles, key=len) # and that's that!
        year = "" # no useful year info
    else:
        raise ValueError("No titles found.")
    # Get some extra information: first and last years of release for releases in each relase group,
    # and the number of release in each group. Will use these later.
    year1s = [min(int(release.get('date','9999')[:4]) for release in group['releases']) for group in groups]
    yearfs = [max(int(release.get('date','0001')[:4]) for release in group['releases']) for group in groups]
    year1s = [9999 if year<1900 else year for year in year1s] # saw a year=1 once (inexplicably)
    yearfs = [9999 if year<1900 else year for year in yearfs] # saw a year=1 once (inexplicably)
    counts = [len(group['releases']) for group in groups]
    for year1,yearf,count,group in zip(year1s,yearfs,counts,groups):
        group['year1'] = year1
        group['yearf'] = yearf
        group['count'] = count
        group['titles'] = list(set(release.get('title','') for release in group['releases']))
    # for year1 in sorted(set(group['year1'] for group in groups)):
    #     groupsA = [group for group in groups if group['year1']==year1]
    #     # Sort by release type
    #     for type_prefs in type_prefs_grouped:
    #         for type_ in type_prefs:
    #             groupsB = [group for group in groupsA if group.get('type','NA')==type_]
    #             # Sort by number of releases in group
    #             for count in sorted(set(counts), reverse=True):
    #                 groupsC = [group for group in groupsB if group['count']==count]
    # for type_prefs in type_prefs_grouped:
    #     # # Sort by first year in group, then by release type
    #     # for year1 in sorted(set(year1s)): # a sorted test returns LIST!
    #     #     groupsA = [group for y,group in zip(year1s,groups) if y==year1]
    #     for type_ in type_prefs:
    #         groupsA = [group for group in groups if group.get('type','NA')==type_]
    #         # Sort by number of releases in group
    #         for count in sorted(set(counts), reverse=True):
    #             groupsB = [group for group in groupsA if group['count']==count]
    #             # And sort by year
    #             for year1 in sorted(set(group['year1'] for group in groups)):
    #                 groupsC = [group for group in groupsB if group['year1']==year1]
    # Get some helper info: need to sort groups by earliest 'official' release year among its release
    # members, and by its type (album vs. single, etc.)
    backupdata = None # empty by default
    type_prefs_grouped = (['Album','Single'],['EP'],['Compilation','Other','Soundtrack','NA'],['Live']) #,('Live',)):
    anglo_countries = ['XW','XE','US','GB','AU','CA','IE'] # have seen "unknown" country show up as japanese/korean
    for itype,type_prefs in enumerate(type_prefs_grouped):
        print(f"Trying albums of type: {', '.join(type_prefs)}.")
        for type_ in type_prefs:
            groupsA = [group for group in groups if group.get('type','NA')==type_]
            for year1 in sorted(set(group['year1'] for group in groupsA)):
                groupsB = [group for group in groupsA if group['year1']==year1]
                # Sort by number of releases in group
                for count in sorted(set(counts), reverse=True):
                    groupsC = [group for group in groupsB if group['count']==count]
                    for group in groupsC:
                        # Confirm user wants to use this album
                        print(f"Release-group candidate: name(s) '{', '.join(group['titles'])}', type '{type_}', "
                            f"count {group['count']}, earliest year '{group['year1']}', latest year '{group['yearf']}'.")
                        if not yesno():
                            continue # only calls yesno() if noconfirm is False! neat, huh?
                        # Get the genres
                        # Will prioritize Discogs genres but use MusicBrainz as backup
                        limit = 5 # no more than 5 genres
                        genres = genres_discogs(group['id'])
                        if len(genres)<limit:
                            genres += genres_musicbrainz(group['recordings'])
                        genres = genres[:limit] # won't trigger error if shorter than limit
                        if options['genreonly'] and len(genres)==0:
                            print("No genre available.")
                            continue
                        # Backup data; use if can't find any images
                        metadata = {'title':title, 'year':year, 'genres':genres, 'image':None}
                        if backupdata is None:
                            backupdata = metadata
                        # Get album art
                        if not options['genreonly']:
                            image = guess_artwork(group['releases'])
                            if image is None:
                                print("No album artwork available.")
                                continue
                            metadata.update({'image':image})
                        return metadata
    print('Failed to find album artwork.')
    if backupdata is None:
        raise ValueError("No metadata to write.")
    return backupdata

################################################################################
# Functions to get genres from both MusicBrainz and Discogs
################################################################################
def genres_translate(genres, discogs=False):
    """Translations. Can deal with ambiguous tag names in MusicBrainz database
    and parse out some undesirable Discogs labels. Only outputs the first N
    genre tags in the list."""
    # Run basic translations, so no duplicates of slightly different things
    badids, newgenres = [], []
    for g,genre in enumerate(genres):
        # Translations
        genre[0] = genre[0].lower() # ensure lower-case
        genre[0] = genre[0].replace('alt-','alternative ') # consistent spelling
        genre[0] = genre[0].replace('alt ','alternative ')
        genre[0] = genre[0].replace('classic','') # sometimes get <something> classic rock
        genre[0] = genre[0].replace('adult','') # always thought these were weird...
        genre[0] = genre[0].replace('&',' and ')
        genre[0] = genre[0].replace('-',' ') # e.g. synth pop
        if 'aor' in genre[0]: # album-oriented-rock to album-rock
            genre[0] = 'album rock' # explicit
        # words = [*set(words)] # have gotten "alternative rock rock"
        seen, words = set(), genre[0].split() # split by spaces
        words = [w for w in words if not (w in seen or seen.add(w))] # seen.add returns None
        if len(words)>0:
            if words[0]=='r' and len(words)>1:
                if words[1]=='b':
                    words = words[:1] + ['and'] + words[1:]
                if words[1]=='n':
                    words[1] = 'and'
            if words[0]=='rock' and len(words)>1: # and words[1]!='and': # except rock & roll
                if words[1]=='n':
                    words[1] = 'and'
                if words[1]=='roll':
                    words = words[:1] + ['and'] + words[1:]
                if words[1]!='and': # e.g. rock pop --> pop rock
                    words = reversed(words)
        genre[0] = ' '.join(words) # uniform spacing
        if ' and ' in genre[0]: # and convert back (have fixed spacing now)
            genre[0] = genre[0].replace('and','&')
        # Split up labels with slash
        split = []
        if '/' in genre[0]:
            split = genre[0].split('/')
        elif ';' in genre[0]:
            split = genre[0].split(';')
        for newgenre in split:
            newgenres.append([newgenre,genre[1]])
            badids.append(g)
        # Rhythm and blues
        if 'r & b' in genre[0]:
            genre[0] = genre[0].replace('r & b','rhythm & blues')
    # Split up tag labels with slash (/) in them
    genres = [genre for g,genre in enumerate(genres) if g not in badids]
    genres = genres + newgenres
    # Repeat our process of adding counts for duplicate genre names
    dict_ = {}
    for genre in genres:
        try: dict_[genre[0]] += genre[1]
        except KeyError:
            dict_[genre[0]] = genre[1]
    genres = [[name,count] for name,count in dict_.items()] # back to list of lists
    genres = sorted(genres, key=lambda x: x[1], reverse=True)
    # And finally filter the managed genre list
    # Unfortunately we have to do this empirical testing nonsense if we want to assimilate
    # the MusicBrainz recording "tags" -- they are sometimes actual genres, but often completely useless
    ignorewords = ['vinyl','cassette','cd','digital','cover', # ...
            'sad','depressing','happy','angry','bowie',
            'context','contest','remark','catchy','playback',
            'genre','collection','original','master','recording','classic','general','oldies','live','track','_',
            'vocal','dance','revolution','song','early','late','revival','singer','songwriter','club', # ...
            # 'alternativo','britannique', # spanish
            '00','90','80','70','60','50','40','30','10','20'] # these aren't even genres; some have them listed
    ignorematch = ['contemporary','rock','pop','country','alternative'] # often there are better/more descriptive ones available
    genres = [genre for genre in genres # iterate through pairs
            if all(dictionary.check(word) for word in genre[0].split()) # make sure words are english
            and (len(genre[0].split())<=3 if '&' in genre[0] else len(genre[0].split())<=2) # limit 2 words, or "a & b"
            and not any(i in genre[0] for i in ignorewords) # catches e.g. "oldies", "70's", etc., and
            and not any(i==genre[0] for i in ignorematch) # catches uninformative names e.g. "pop"
            and genre[1]>0] # make sure at least one "count" is present
    # Save genres in Title Case; make a few exceptions (again, from empirical testing)
    genres = [genre[0].title() for genre in genres] # all genres
    genres = [genre.replace('Am ','AM ') for genre in genres] # e.g. AM pop
    # And finally get unique values, preserving order
    seen = set() # start an empty set
    genres = [genre for genre in genres if not (genre in seen or seen.add(genre))]
    return genres # these are now unique!
def genres_discogs(rgid):
    """Gets the discogs page linked to a release group, and pulls the genre info
    or album artwork from there."""
    # Get the MusicBrainz URL from the releasegroup id
    url = f"https://musicbrainz.org/release-group/{rgid}"
    try: content = requests.get(url).content
    except ConnectionError:
        raise ValueError('Seems to be invalid release-group id :(')
    page = BeautifulSoup(content, 'lxml').decode() # converts to string
    # Parse HTMl page to get the discogs id
    # From: https://stackoverflow.com/questions/15517483/how-to-extract-urls-from-an-html-page-in-python
    urls = []
    url = True # fill initial case
    while url: # while non-empty
        url, n = findurls(page)
        page = page[n:]
        if url: urls.append(url)
    # Get discogs URL (set comprehension, because want unique result)
    # And parse out the discogs release id
    urls = [*{url.rstrip('/') for url in urls if 'discogs' in url}]
    if len(urls)==0:
        print('No Discogs genres found: could not find URL on MusicBrainz page.')
        return []
    if len(urls)>1:
        print('No Discogs genres found: ambiguous number of URL candidates on MusicBrainz page.')
        return []
    master = os.path.basename(urls[0]) # because it is the last part after slash
    try: master = int(master)
    except TypeError:
        print('No Discogs genres found: could not parse the URL found on MusicBrainz page.')
        return []
    # Finally, call discogs by release-group id
    data = client.master(master) # this function just looks up id, returns stuff
    styles = data.fetch('styles') # sometimes doesn't return everything in data dict; maybe is not
    genres = data.fetch('genres') # add genres
        # supposed to be accessed by users; only use fetch from now on
    if styles is None: styles = []
    if genres is None: genres = []
    genres = genres+styles
    if len(genres)==0:
        print("No Discogs genres found: none listed under the 'master' release.")
        return []
    genres = [genre for genre in genres if genre not in ('Contemporary','Soundtrack','Score')]
    genres = [[genre, 1] for genre in genres] # name, count format
    if options['debug']:
        print(f'Discogs genres discovered:')
        for genre,count in genres:
            print(f"{genre.title()}: {count:d}")
    genres = genres_translate(genres)
    if len(genres)==0:
        print("No Discogs genres found: none left after translation.")
        return []
    print(f"Discogs genres for writing: {', '.join(genres)}.")
    return genres
def genres_musicbrainz(recordings):
    """Gets the genres from the MusicBrainz tag-list associated with a list
    of recordings. Ouputs count-genres lists."""
    # First get list of tags, and create list of tag-count pairs
    tags = {}
    for recording in recordings:
        tagl = recording.get('tag-list',{})
        for tagd in tagl: # dictionaries
            if tagd['name'] not in tags:
                tags[tagd['name']] = int(tagd['count'])
            else:
                tags[tagd['name']] += int(tagd['count'])
    genres = sorted(list(tags.items()), key=lambda x: x[1], reverse=True) # (genre,count) tuples
    genres = [[*genre] for genre in genres] # convert to lists
    if options['debug']:
        print(f'MusicBrainz genres discovered:')
        for genre,count in genres:
            print(f"{genre.title()}: {count:d}")
    genres = genres_translate(genres)
    if len(genres)==0:
        print("No MusicBrainz genres found: couldn't find any useful recording tags.")
        return []
    print(f"MusicBrainz genres for writing: {', '.join(genres)}.")
    return genres

################################################################################
# Function to get "best" artwork from a release group
################################################################################
def guess_artwork(releases):
    """Gets album artwork. Note country is tricky; often japanese releases have 
    japenese text on them, but seems that European release are usually good and sometimes
    are the only available digital copies. Maybe just ignore asian countries?"""
    # First, go by release medium
    years = [int(release.get('date','0001')[:4]) for release in releases]
    media_pref = ('digital','usb','cd','dvd','cassette','vinyl','xxxxx','other')
    anglo_countries = ['NA','XU','XW','XE','US','GB','AU','CA','IE','other']
    # anglo_countries = ('US','GB','CA','AU','IE','JP','XE','XU','XW','NA')
        # unknown countries/broad regions seem to be less likely to not have annoying extra border text
        # e.g. Beatles Sgt. Pepper's: all but the NA-digital-release have "anniversary edition" on edge
    filter_known = [False for release in releases] # want to catch any unknown media
    for m,medium in enumerate(media_pref):
        if medium=='other': # we are at the end; see if any media were left
            filter_ = [not known for known in filter_known] # iterate over what's left
        else: # filter, and add known media to lsit
            filter_ = [any(medium in _.get('format','xxxxx').lower() for _ in release.get('medium-list',[{}]))
                for release in releases] # last one is unknown
            filter_known = [f1 or f2 for f1,f2 in zip(filter_,filter_known)]
        releasesA = [r for f,r in zip(filter_,releases) if f]
        yearsA = [y for f,y in zip(filter_,years) if f]
        for year in sorted(set(yearsA), reverse=True):
            releasesB = [r for r,y in zip(releasesA,yearsA) if y==year]
            for country in anglo_countries:
                # Also try non-anglo countries (sometimes only one available)
                if country=='other':
                    releasesC = [r for r in releasesB if r.get('country','NA') not in anglo_countries]
                else:
                    releasesC = [r for r in releasesB if r.get('country','NA')==country]
                # Try to return image art; remaining releases, choose order at random
                for release in releasesC:
                    # User input
                    rmedia = [m.get('format','') for m in release.get('medium-list',[{}])]
                    rcountry, rtitle = release.get('country',''), release.get('title','')
                    print(f"Release candidate: name '{rtitle}', media '{', '.join(rmedia)}', "\
                        f"country '{rcountry}', year '{year}'.")
                    if not yesno():
                        continue
                    # Pull artwork
                    try: 
                        data = mb.get_image_front(release.get('id',''))
                    except ResponseError:
                        continue
                    # Manipulate
                    image = Image.open(BytesIO(data))
                    print(f"Image shape: {image.size[0]} x {image.size[1]}. Warping "\
                            "to square if not equal.")
                    if image.size[0]!=image.size[1]:
                        sqsize = min(image.size)
                        image = image.resize((sqsize,sqsize), Image.ANTIALIAS)
                        data = BytesIO()
                        image.save(data, format='JPEG')
                        data = data.getvalue()
                    return data

if __name__ == "__main__":
    ############################################################################
    # Parse all command-line arguments
    # Decided to make no-filtering by "words" the default, causes more trouble
    # than necessary! As long as we have the artist search we are fine.
    ############################################################################
    url = '' # by default, write nothing
    options = ['filter', 'genreonly', 'debug', 'noconfirm', 'noconfig']
    options = {option: False for option in options} # the default settings
    filepaths = []
    for arg in sys.argv[1:]:
        if arg.startswith('--'):
            if arg[2:]=='url': # better than trying implicit search
                url = arg[2:].split('=')
                if len(url)==1:
                    raise ValueError("Invalid url argument.")
                url = ''.join(url[1:]) # re-combine after the first = sign
            if arg[2:] not in options: # searches keys by default
                raise ValueError("Invalid '--' argument.")
            options[arg[2:]] = True # option enabled
        else:
            filepaths.append(arg)
    # filepath = ' '.join(filepath) # so don't have to escape spaces
    for filepath in filepaths: # instead require escapes and can loop through
        ########################################################################
        # Check existence of files and infer artist/track information
        ########################################################################
        if not os.path.exists(filepath):
            raise ValueError(f"Could not find file {filepath}.")
        filename = os.path.splitext(os.path.basename(filepath))[0].split(' - ')
        if len(filename)!=2:
            raise ValueError("Filename is not in the '<artist> - <title>' format.")
        artist, recording = filename # convert to artist and track

        ########################################################################
        # Open file, for different types
        # Currently have compatibility with MP4 and ID3 tags
        ########################################################################
        try: # read AAC info
            id3 = False # aac
            tags = MP4(filepath)
            print('Adding metadata according to AAC specifications.')
        except MP4StreamInfoError:
            id3 = True # mp3
            try: # check header presence
                tags = ID3(filepath)
                print('Adding metadata using the ID3 header.')
            except ID3NoHeaderError:
                raise ValueError("Format may be incorrect.")

        ########################################################################
        # Call functions and apply metadata
        ########################################################################
        print(f"Retrieving metadata for \"{artist} - {recording}\"...")
        artist, recordings = guess_recordings(artist, recording) # pull just the recordings
        albumprops = guess_album(recordings) # pull album year, artwork, and genres
        recording = recordings[0]['title'] # just use the first one
        # Special options for just tagging genres
        if options['genreonly']:
            print(f"Adding genres: '{albumprops['genres']}'")
            if id3:
                tags["TCON"] = TCON(text=albumprops['genres'][0], genres=albumprops['genres'])
                tags.save(filepath) # supply path, in case we are creating for first time
            if not id3:
                tags["\xa9gen"] = [*albumprops['genres']]
                tags.save()
            sys.exit()
        # Addd MP4-format metadata
        print(f"Adding metadata: MusicBrainz artwork, artist '{artist}', album "
            f"'{albumprops['title']}', year '{albumprops['year']}', "
            f"genres {'<none>' if len(albumprops['genres'])==0 else ', '.join(albumprops['genres'])}.")
        if id3: # First try editing an ID3 header, if has one
            # Below are ID3v2, not ID3v2.4 (default format of mutagen, and modern version)
            tags.delete(filepath) # delete old data, if we downloaded from somewhere; want to assigne my better data
            # General stuff
            tags["TPE1"] = TPE1(text=artist)
            tags["TIT2"] = TIT2(text=recording) # just track name
            tags["COMM"] = COMM(text=url, lang="eng", desc="URL")
            # Album stuff
            # tags["TYER"] = TYER(text=data['year']) # doesn't show up in swinsian, for some reason
            # tags["TORY"] = TORY(text=data['year']) # maybe this will
            # tags["TDAT"] = TDAT(text=data['year']) # recording date(s) (?)
            # tags["TRDA"] = TRDA(text='0101') # recording date, MMDD
            tags["TDOR"] = TDOR(text=albumprops['year']) # original release time
            tags["TDRC"] = TDRC(text=albumprops['year']) # recording time
            tags["TDRL"] = TDRL(text=albumprops['year']) # release time
            tags["TALB"] = TALB(text=albumprops['title']) # album
            tags["TOAL"] = TOAL(text=albumprops['title']) # original album
            if albumprops['image'] is not None:
                tags["APIC"] = APIC(data=albumprops['image'])
            if albumprops['genres'] is not None:
                tags["TCON"] = TCON(text=albumprops['genres'][0], genres=albumprops['genres'])
            tags.save(filepath) # supply path, in case we are creating ID3 header for first time
        if not id3: # Or just edit as an AAC file
            # General stuff
            tags["\xa9ART"] = [artist] # artist; includes whether "The" is in front, best punctuation, etc.
            tags["\xa9nam"] = [recording] # track name
            tags["\xa9cmt"] = [url] # embed URL as comment
            # Album stuff
            tags["\xa9day"] = [albumprops['year']]
            tags["\xa9alb"] = [albumprops['title']] # album, from lookup
            if albumprops['image'] is not None:
                tags["covr"] = [MP4Cover(albumprops['image'], imageformat=MP4Cover.FORMAT_JPEG)]
            if albumprops['genres'] is not None:
                tags["\xa9gen"] = [*albumprops['genres']] # genres
            tags.save() # don't need to re-supply with path

