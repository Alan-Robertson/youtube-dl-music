#!/usr/bin/env python
"""
This script adds metadata from the MusicBrainz database based on the <artist> - <title> 
from so-formatted audio files. If file is not AAC/MP4 (iTunes default), will use ID3v2.4 header; 
otherwise, will use special MP4 metadata assignment. Requires musicbrainzngs (use pip install).
"""
# TODO:
# 1) Maybe pull cover art from Discogs master-release info if it is available; Discogs
# could be generally more reliable there. But still use MusicBrainz for searching because impossible
# to search for recording and artist at same time with current Discogs API.
# 2) Try to get rid of the current empirical steps, like genre-tag filtering (usually to
# fix the weird MusicBrainz results) and artist name verification. For the former, could just get
# Discogs genre from **every available Master release** from the groups of recordings.

# Tagging tools
from mutagen.mp4 import MP4, MP4Cover, MP4StreamInfoError
from mutagen.id3 import ID3, ID3NoHeaderError, TIT2, TPE1, TCON, TALB, TOAL, TDRC, TDOR, TDRL, APIC, COMM
    # PE1 is artist, CON is genre, ALB is album name, YER is year of recording,
    # ORY is original release year, IT2 is song title, APIC is artwork, and COMM is comment
# Database APIs
import discogs_client
import musicbrainzngs as mb
from musicbrainzngs.musicbrainz import ResponseError
# For getting discogs stuff
from bs4 import BeautifulSoup # distills HTML code into human-readable stuff
import requests
# For processing image
from io import BytesIO
from PIL import Image # check out image size with this stuff
# For memory
import pandas as pd
# Miscellaneous
import re # needed later
import sys
import os
from enchant import Dict
import unidecode as ud # converting accents to normal characters
# Dictionary setup
dictionary = Dict('en_US')
for exception in ['indie','fi','&']: # as in lo-fi, hi-fi
    dictionary.add(exception) # not in dictionary, but we allow it
        # also need to add ampersand, because returns False

################################################################################
# Configure
################################################################################
# File names
storage = os.path.dirname(os.path.realpath(__file__))
config = f"{storage}/config"
metaconfig = f"{storage}/metaconfig"
metanoconfig = f"{storage}/metanoconfig"
genrelist = f"{storage}/genrelist"
# Read valid genres
with open(genrelist,"r") as f:
    discogs_genres = [s.strip() for s in f.readlines()] # strip removes newline chars
genrelist = [genre for genre in genrelist # ignore certain genres
    if genre not in ('Contemporary','Soundtrack','Score')]
# Read config file
if not os.path.exists(config):
    raise IOError("To get metadata, you must add fields to a config file called \"config\" in the project directory.")
with open(config, "r") as file:
    config = file.readlines()
config = [l.strip().replace("\"",'').replace("'",'') for l in config]
config = [l.split('=') for l in config if l!=''] # tuples of pairs
if not all(len(t)==2 for t in config):
    raise ValueError("Formatting error in config file. Lines must look like \"key = value\".")
config = {t[0].strip(): t[1].strip() for t in config} # to dictionary
if 'username' not in config or 'password' not in config:
    raise ValueError("Cannot find MusicBrainz keys in config file. Add the lines \"username = <username>\" and "
            "\"password = <password>\" to enable metadata tagging.")
if 'token' not in config:
    raise ValueError("Cannot find Discogs token in config file. Add the line \"token = <token>\" "
            "to enable metadata tagging.")
# Config MusicBrainz
mb.auth(config['username'], config['password'])
mb.set_useragent('Self', 'NA', contact=config.get('contact',''))
# Config Discogs
client = discogs_client.Client('Personal', user_token=config['token'])
# Some global options
media_pref = ('digital','usb','cd','dvd','cassette','vinyl','xxxxx','other')
anglo_countries = ['NA','XU','XW','XE','US','GB','AU','CA','IE','other']
# anglo_countries = ['XW','XE','US','GB','AU','CA','IE']
# anglo_countries = ('US','GB','CA','AU','IE','JP','XE','XU','XW','NA')
    # unknown countries/broad regions seem to be less likely to not have annoying extra border text
    # e.g. Beatles Sgt. Pepper's: all but the NA-digital-release have "anniversary edition" on edge

################################################################################
# Helper functions
################################################################################
def yesno():
    # Requests user yes/no input and parses
    if options['noconfirm']:
        return True
    while True: # just keep going until get valid one
        response = input('Confirm (y/n)?')
        if len(response)>0:
            if response[0].lower()=='n':
                return False # continue?
            elif response[0].lower()=='y':
                return True # continue?
        print('Invalid choice.') 
def findurls(page):
    # Gets URL data from HTML lines
    # Each page.find moves the "reader/parser" farther down the object
    start_link = page.find("a href")
    if start_link == -1:
        return None, 0
    start_quote = page.find('"', start_link)
    end_quote = page.find('"', start_quote+1)
    url = page[start_quote+1:end_quote]
    return url, end_quote
def findstyles():
    # Get Discogs styles
    # Need to convert non-ASCII characters back to unicode
    # See 1st comment on this answer: https://stackoverflow.com/a/5187097/4970632 
    data = ''
    prefix = 'https://reference.discogslabs.com/browse/style?page='
    for page in range(1,11+1):
        content = requests.get(prefix+str(page)).content # is type 'bytes'
        data += BeautifulSoup(content, 'lxml').decode() # is type 'string'
    end_keys = [m.end() for m in re.finditer("\"title\":", data)]
    start_quotes = [data.find('"',k) for k in end_keys]
    end_quotes = [data.find('"',q+1) for q in start_quotes]
    styles = [data[s+1:e] for s,e in zip(start_quotes,end_quotes)]
    styles = [bytes(s,'utf-8').decode('unicode_escape') for s in styles]
    return styles

################################################################################
# Function to get recording data from just the simple artist-recording names
################################################################################
def guess_recordings(artist, recording): #artistnames, artistids):
    """Searches MusicBrainz for the artist and recordings corresponding to input.
    Tries to do this intelligently, and account for some rare special cases."""
    def words(string):
        # Elminates all non-alphanumeric characters and parentheticals.
        # Allows for some limited exceptions
        iwords = []
        for istring in string.split('/'):
            istring = ud.unidecode(string) # get plain ASCII letters from accents
            istring = re.sub("\.","",istring) # e.g. S.O.S. goes to SOS
                # make sure to escape the '.'! that was a really dumb bug!
            istring = re.sub("&"," and ",istring) # standardize and symbols
            istring = re.sub(r"\(.*\)","",istring) # delete stuff in parentheses
            istring = re.sub(r"“.*”","",istring) # delete stuff in quotes
            istring = re.sub(r"[^\w\s]"," ",istring) # delete punctuation and stuff
            istring = istring.split(" and ")[0] # e.g. Joan Jett "and the Blackhearts"
            istring = istring.split(" ft ")[0] # e.g. Queen ft. David Bowie
            iwords += [[w for w in istring.lower().split()
                if w!='the' and len(w)>1]] # just add the words; the accounts for e.g. The Stooges
            # iwords += [[w for w in istring.lower().split()
            #     if w!='the' and len(w)>1]] # ignore single letters
        return iwords
    def parse(choices, N): # N is max possible number
        # Helper function for parsing user response
        if len(choices)==0:
            print('Invalid choice.')
            return None
        if choices=='0':
            choices = [c+1 for c in range(N)]
        else:
            try: choices = [int(c) for c in choices.split(',')]
            except TypeError:
                print('Input must be integer.')
                return None
        # Make sure they are all in valid range
        if any(c<0 for c in choices):
            print('Integer must be >=0.')
            return None
        if any(c>N for c in choices):
            print(f'Integer must be <={N}.')
            return None
        return choices
    def fixartist(artist):
        # Helper function that does a special artist-name translation
        # Different from the "words" function; that is meant to deal with punctuation
        # and accents and stuff. This is generally empirical.
        if '“' in artist and '”' in artist: # e.g. Haywire “Haywire Mac” McClintoc
            artist = artist.split('“')[0] + artist.split('”')[-1]
        if '∆' in artist: # stylized-name does not match database-name often
            artist = re.sub('[∆]','A',artist)
        if artist=='Chet Faker': # all releases are under this name in database
            artist = 'Nick Murphy'
        if artist=='Hall and Oates': # listed separately for some reason
            artist = 'Daryl Hall and John Oates'
        return artist
    # Premature track and artist filtering, so the "strict search" will give
    # reasonable results.
    artist = artist.split('ft.')[0] # get first artist in name; they will be credited separately
    recording = recording.split('+')[0] # get first song in combo
    recording = re.sub(r"\(.*\)"," ",recording) # delete stuff in parentheses
    recording = " ".join(recording.split()) # single spaces only
    # (Step 0) Search the database with a strict search, results should be pretty darn good
    # Results will have list of artist dictionaries under the "artist-credit" fields
    # For some reason each artist dictionary is embedded in a singleton dictionary with key "artist"
    # searchrecording = ' '.join([w for w in recording.split() # empirical hack; sometimes use wrong article/prep
    #     if w.lower() not in ['a','in','the','on','of','and','or','for']])
    # TODO: Apparently strict search actually requires EXACT NAME-MATCH of file but somehow
    # can accept some VARIATIONS in artist name (had some examples)... actually THAT'S WRONG because
    # search for "Mother" STILL TURNS UP those bad results. But "Born On A Bayou" failed vs. "The Bayou"
    # because CAN HAVE EXTRA WORDS, BUT MUST HAVE AT LEAST THE CORRECT ONES
    offset = 0 # start at 0 offset
    recordings = [] # put recordings here
    triedagain = False # have we tried another search?
    newrecordings = [None]
    while len(newrecordings)>0:
        # Get recordings; can only run through 100 at a time at most, so make sure to get all
        # newrecordings = mb.search_recordings(searchrecording, artist=artist,
        #         strict=True, limit=100, offset=offset)['recording-list']
        if offset>0: print(f'Found {offset} recordings...') # message
        if offset%100!=0: break # makes things a bit quicker
        newrecordings = mb.search_recordings(recording, artist=artist,
                strict=True, limit=100, offset=offset)['recording-list']
        # print([recording.get('title','') for recording in newrecordings])
        # print([recording.get('artist-credit',[{}])[0].get('artist',{}).get('name','') for recording in newrecordings])
        if offset==0 and len(newrecordings)==0:
            # Typo in name; try to repair! Then re-run loop with new name.
            if triedagain:
                raise ValueError("No recordings found. You might have a typo in your artist or title name. "
                    "Tried to repair typo with non-strict search, with no luck.")
            triedagain = True
            newrecordings = [None] # to reset list
            try: # try the search again
                # common = lambda l: max(set(l), key=l.count) # most common element
                # newrecording = mb.search_recordings(recording, artist=artist,
                #         strict=False, limit=50)['recording-list'] # new search
                # recording = print([r.get('title','') for r in newrecording]) # the recording
                # recording = common([r.get('title','') for r in newrecording]) # the recording
                # artist = [r.get('artist-credit',[{}])[0].get('artist',{}).get('name','') for r in newrecording] # get list of artists
                # print(artist)
                # artist = common([a for r,a in zip(newrecording,artist) if r.get('title','')==recording]) # the artist
                # print(recording,artist)
                newrecording = mb.search_recordings(recording, artist=artist,
                        strict=False, limit=50)['recording-list'][0]
                recording, artist = newrecording['title'], newrecording['artist-credit'][0]['artist']['name']
                print(f"Warning: Search failed. Will try again with artist \"{artist}\" and "
                        f"recording name \"{recording}.\"")
            except (IndexError, KeyError): # no results or something
                raise ValueError("No recordings found. You might have a typo in your artist or title name. "
                    "Tried to repair typo with non-strict search, with no luck.")
        else:
            # Add to list of names
            if triedagain and offset==0: # only after we were successful
                print(f"Warning: Probable typo in your filename; should be should be \"{artist} - {recording}.\"")
            recordings.extend(newrecordings)
            offset += len(newrecordings)
    if len(recordings)==0:
        raise ValueError("No recordings found. You might have a typo in your title or artist name.")
    recartists = [irecording['artist-credit'][0] for irecording in recordings
            if len(irecording.get('artist-credit',[]))>0] # verify length is non-zero
    recartists = [recartist.get('artist',{}) for recartist in recartists 
            if type(recartist) is dict] # now extract dictionaries with actual information
    recartistids = [recartist.get('id','') for recartist in recartists]
    # (Step 1) Perform clever filter to unique artists associated with the recordings
    # This is generally rare with strict search, but we want to be extra careful
    uqartistids = set() # initialize empty set
    uqartists = [recartist for recartist in recartists
            if recartist.get('id','') not in uqartistids # check if already recorded this one
            and not uqartistids.add(recartist.get('id',''))] # if not, add to set during comprehension
                # must be and statement, because if or, python will only execute the first one
    if options['filter']: # filter words
        # print([uqartist.get('name','') for uqartist in uqartists])
        uqartists = [uqartist for uqartist in uqartists if # check equality of word-lists
                words(fixartist(uqartist.get('name','')))==words(fixartist(artist))]
        # print([uqartist.get('name','') for uqartist in uqartists])
    if len(uqartists)==0:
        raise ValueError("No recordings found. You might have a typo in your artist name.")
    if len(uqartists)>1:
        # There is more than one unique artist in the list; we must pick one
        # Load the config file, and see if a previous response is in there
        for i,uqartist in enumerate(uqartists): # simple message
            print(f"{i+1:d}: {uqartist.get('name','')} "\
                    f"({uqartist.get('disambiguation','')})".split('()')[0])
        try: df = pd.read_csv(metaconfig, index_col=0, header=0, dtype=str)
        except FileNotFoundError:
            df = pd.DataFrame(index=[], columns=['choice'])
        if not options['noconfig'] and artist in df.index.values: # load previous user response
            ids = df.loc[artist].values[0].split(',') # list of ids user chose
            choices = [c+1 for c,uqartist in enumerate(uqartists) if uqartist.get('id','') in ids]
            print(f'Loaded previous response: {",".join(str(c) for c in choices)}.') # the last choices
        else: # get and save user response
            choices = None # initialize with this
            while choices is None: # if None there was error, and loop will repeat
                choices = input('Which artist number(s) should we use (enter 0 for all)?')
                choices = parse(choices, len(uqartists)) # returns None on error
            ids = ','.join(uqartists[c-1].get('id','') for c in choices)
            df.loc[artist] = ids # add ids to dataframe
            df.to_csv(metaconfig)
        recordings = [irecording for irecording,recartistid in zip(recordings,recartistids)
            if recartistid in ids] # make sure they are in user-selected choice
    else:
        # Don't need a list of possible ids; just use the only one left
        recordings = [irecording for irecording,recartistid in zip(recordings,recartistids)
            if recartistid==uqartists[0].get('id','')] # make sure they are in user-selected choice
    print(f'{len(recordings)} recordings with valid artist found.')
    # (Step 2) Filter out bad/unwanted recordings
    # Translate recordings, so no rejection due to capitalization/punctuation
    if options['filter']:
        if options['debug']:
            rectitles = {irecording.get('title','') for irecording in recordings}
            print('Discovered track names:',*rectitles,sep='\n')
        recordings = [irecording for irecording in recordings if # check equality of word-lists
            any(x==y for x,y in zip(words(recording),words(irecording.get('title',''))))]
        if options['debug']:
            rectitles = {irecording.get('title','') for irecording in recordings}
            print('Filtered track names:',*rectitles,sep='\n')
    print(f'{len(recordings)} recordings with valid title found.')
    if len(recordings)==0:
        raise ValueError("No recordings found. You might have a typo in your title name.")
    # Return results
    return artist, recordings

################################################################################
# Function to guess album from list of recording dictionaries
################################################################################
def guess_album(recordings):
    """Guesses album group from input info. Returns a dictionary of metadata information
    including year, album title, image, and genres."""
    # Start with simple list of releases and recordings, as two separate groups
    # Note the recording list has repeated items to match placement of corresponding releases
    releases = [release for recording in recordings for release in recording.get('release-list',[])]
    recordings = [recording for recording in recordings for release in recording.get('release-list',[])]
        # keep the recordings in-tact
    # Get families of releases belonging to release groups
    # This stuff is complicated and I don't want to look at it again
    groups = []
    duplicates = 0 # will record number of duplicates removed
    rgroupids = [release.get('release-group',{}).get('id','') for release in releases] # 1:1 correspondance with above
    uniqueidxs = [rgroupids.index(r) for r in set(rgroupids)] # unique indices
    for uidx in uniqueidxs: # will iterate through unique releases
        # Get release group dict, and add to it the releases we've already 
        # loaded as a list under the 'releases' keyword
        group = releases[uidx].get('release-group',{})
        greleases = [release for release,rgroupid in zip(releases,rgroupids) if rgroupid==rgroupids[uidx]]
        grecordings = [recording for recording,rgroupid in zip(recordings,rgroupids) if rgroupid==rgroupids[uidx]]
        # Also make sure the release list is unique (potential for overlap in release names, if
        # multiple recording ids were accepted)
        greleaseids = [grelease.get('id','') for grelease in greleases]
        guniqueidxs = [greleaseids.index(g) for g in set(greleaseids)]
        greleases = [grelease for idx,grelease in enumerate(greleases) if idx in guniqueidxs]
        if len(greleases)<len(greleaseids): # black magic
            duplicates += len(greleaseids)-len(greleases)
        # Pop the release-group dictionary from the release list
        # Then save the releases/recordings corresponding to this group
        for grelease in greleases:
            grelease.pop('release-group')
        group['releases'] = greleases
        group['recordings'] = grecordings
        groups.append(group)
    print(f"{len(releases):d} releases consolidated into {len(groups)} release groups ({duplicates:d} duplicates removed).")
    # Add new information to the original release-group dictionaries
    # This information will be used to sort albums by a hieararchy of preferred characteristics
    for group in groups:
        group['count'] = len(group['releases'])
        group['years'] = [int(release.get('date','9999')[:4]) for release in group['releases']]
        group['years'] = [*{year for year in group['years'] if 1900<year<2100}]
        group['titles'] = [*{release.get('title','') for release in group['releases']}]
    # Get the recording year as simply the earliest date-release amongst releases in the release group
    # Will get the title in the loop below
    title = None
    year = str(min(min(group['years']) if len(group['years'])>0 else 9999 for group in groups))
    year = '' if year=='9999' else year
    # Get some helper info: need to sort groups by earliest 'official' release year among its release
    # members, and by its type (album vs. single, etc.)
    backupdata = None # empty by default
    type_prefs_grouped = (['Album','Single'],['EP'],['Compilation','Other','Soundtrack','NA'],['Live']) #,('Live',)):
    for itype,type_prefs in enumerate(type_prefs_grouped):
        print(f"Trying albums of type: {', '.join(type_prefs)}.")
        for type_ in type_prefs:
            groupsA = [group for group in groups if group.get('type','NA')==type_]
            for firstyear in sorted(set(min(group['years']) for group in groupsA)):
                groupsB = [group for group in groupsA if min(group['years'])==firstyear]
                # Sort by number of releases in group
                for count in sorted(set(group['count'] for group in groupsB), reverse=True):
                    groupsC = [group for group in groupsB if group['count']==count]
                    for group in groupsC:
                        # Get the title; choose as the title of a release in the PREFERRED
                        # group for getting artwork; not the first one that actually has artwork
                        if title is None:
                            title = min((title for title in group['titles'] if
                                group.get('country','NA') in anglo_countries), key=len)
                        # Confirm user wants to use this album for artwork
                        print(f"Release-group candidate: name(s) '{', '.join(group['titles'])}', type '{type_}', "
                            f"count {group['count']}, earliest year '{min(group['years'])}', latest year '{max(group['years'])}'.")
                        if not yesno():
                            continue # only calls yesno() if noconfirm is False! neat, huh?
                        # Get the genres
                        # Will prioritize Discogs genres but use MusicBrainz as backup
                        limit = 5 # no more than 5 genres
                        added = set() # start empty set
                        genres = [genre for genre in genres_discogs(group['id'])
                            if genre not in added and not added.add(genre)] # unique, preserve order
                        if len(genres)<limit:
                            genres += [genre for genre in genres_musicbrainz(group['recordings'])
                                if genre not in added and not added.add(genre)] # still preserve order
                        genres = genres[:limit] # won't trigger error if shorter than limit
                        if options['genreonly'] and len(genres)==0:
                            print("No genre available.")
                            continue
                        # Backup data; use if can't find any images
                        metadata = {'title':title, 'year':year, 'genres':genres, 'image':None}
                        if backupdata is None:
                            backupdata = metadata
                        # Get album art
                        if not options['genreonly']:
                            image = guess_artwork(group['releases'])
                            if image is None:
                                print("No album artwork available.")
                                continue
                            metadata.update({'image':image})
                        return metadata
    print('Failed to find album artwork.')
    if backupdata is None:
        raise ValueError("No metadata to write.")
    return backupdata

################################################################################
# Functions to get genres from both MusicBrainz and Discogs
################################################################################
def genres_discogs(rgid):
    """Gets the discogs page linked to a release group, and pulls the genre info
    or album artwork from there."""
    # Get the MusicBrainz URL from the releasegroup id
    url = f"https://musicbrainz.org/release-group/{rgid}"
    try: content = requests.get(url).content
    except ConnectionError:
        raise ValueError('MusicBrainz release-group ID appears to be invalid.')
    page = BeautifulSoup(content, 'lxml').decode() # converts to string
    # Parse HTMl page to get the discogs id
    # From: https://stackoverflow.com/questions/15517483/how-to-extract-urls-from-an-html-page-in-python
    urls = []
    url = True # fill initial case
    while url: # while non-empty
        url, n = findurls(page)
        page = page[n:]
        if url: urls.append(url)
    # Get discogs URL (set comprehension, because want unique result)
    # And parse out the discogs release id
    urls = [*{url.rstrip('/') for url in urls if 'discogs' in url}]
    if len(urls)==0:
        print('No Discogs genres found: could not find URL on MusicBrainz page.')
        return []
    if len(urls)>1:
        print('No Discogs genres found: ambiguous number of URL candidates on MusicBrainz page.')
        return []
    master = os.path.basename(urls[0]) # because it is the last part after slash
    try: master = int(master)
    except TypeError:
        print('No Discogs genres found: could not parse the URL found on MusicBrainz page.')
        return []
    # Finally, call discogs by release-group id
    data = client.master(master) # this function just looks up id, returns stuff
    styles = data.fetch('styles') # sometimes doesn't return everything in data dict; maybe is not
    genres = data.fetch('genres') # add genres
        # supposed to be accessed by users; only use fetch from now on
    if styles is None: styles = []
    if genres is None: genres = []
    genres = genres+styles
    if len(genres)==0:
        print("No Discogs genres found: none listed under the 'master' release.")
        return []
    if options['debug']:
        print(f'Discogs genres discovered:')
        for genre in genres:
            print(genre.title())
    genres = [g for g in genres if g in discogs_genres] # don't want e.g. "Rock"
    if len(genres)==0:
        print("No Discogs genres found: none left after translation.")
        return []
    print(f"Discogs genres for writing: {', '.join(genres)}.")
    return genres
def genres_musicbrainz(recordings):
    """Gets the genres from the MusicBrainz tag-list associated with a list
    of recordings. Ouputs count-genres lists."""
    # First get list of tags, and create list of genre-count pairs
    # Add counts for tags that are duplicated
    tags = {}
    for recording in recordings:
        tagl = recording.get('tag-list',{})
        for tagd in tagl: # dictionaries
            if tagd['name'] not in tags:
                tags[tagd['name']] = int(tagd['count'])
            else:
                tags[tagd['name']] += int(tagd['count'])
    genres = sorted(list(tags.items()), key=lambda x: x[1], reverse=True) # (genre,count) tuples
    genres = [[*genre] for genre in genres] # convert to lists
    if options['debug']:
        print(f'MusicBrainz genres discovered:')
        for genre,count in genres:
            print(f"{genre.title()}: {count:d}")
    # Split up strings suspected to contain multiple genres
    has2, slashgenres = [], []
    for g,genre in enumerate(genres):
        split = []
        if '/' in genre[0]:
            split = genre[0].split('/')
        elif ';' in genre[0]:
            split = genre[0].split(';')
        for newgenre in split:
            slashgenres.append([newgenre,genre[1]])
            has2.append(g)
    # Now ignore the genre-names with slashes in them, and re-combine from the
    # slashgenres list
    genres = [genre for g,genre in enumerate(genres) if g not in has2]
    genres = genres + slashgenres
    # Run basic translations; maybe a tag is something we want, just under
    # slightly different name than Discogs conventions
    newgenres = []
    for g,genre in enumerate(genres):
        # First split up the string into "words"
        name, count = genre
        name = name.lower() # ensure lower-case
        name = name.replace(' and ',' & ') # discogs uses ampersand
        name = name.replace('&',' & ') # make sure separated by space
        name = name.replace('-',' ')
        name = name.replace('-',' ') # different character?
        seen, words = set(), name.split() # split by spaces
        words = [w for w in words if not (w in seen or seen.add(w))] # seen.add returns None
        if len(words)==0:
            newgenres += [['', 0]]
            continue
        # Empirical approaches; edit this as seen fit
        if words[0]=='alt':
            words[0] = 'alternative'
        if words[0]=='r' and words[-1]=='b':
            words = ['rhythm','&','blues']
        if words[0]=='rock' and words[-1]=='roll':
            words = ['rock','&','roll']
        if words[0]=='progressive':
            words[0] = 'prog'
        if 'adult' in words:
            words = [w for w in words if w!='adult']
        if 'aor' in words: # aor to album rock
            words = ['album','rock']
        if 'classic' in words and 'rock' in words: # sometimes get <something> classic rock
            words = ['classic','rock']
        if words[0]=='rock' and len(words)>1: # rock fixes
            if words[1]!='&': # e.g. rock pop --> pop rock
                words = reversed(words)
        name = ' '.join(words) # uniform spacing
        newgenres += [[name, count]]
    genres = newgenres
    # If genre-name is found twice, add their counts
    genrecount = {}
    for genre in genres:
        try: genrecount[genre[0]] += genre[1]
        except KeyError:
            genrecount[genre[0]] = genre[1]
    genres = [[genre,count] for genre,count in genrecount.items()] # back to list of lists
    genres = sorted(genres, key=lambda x: x[1], reverse=True)
    # Filter the genre list by Discogs genres, and make sure the too-vague
    # genres are not included in final output
    seen = set() # start an empty set
    standardize = lambda string: ' '.join(re.sub('\W',' ',string).split()).lower() # non-alphenumeric char == \W
    discogs_std = [standardize(g) for g in discogs_genres] # standard names for comparison
    genres = [(genre[0].title(), genre[1]) for genre in genres if standardize(genre[0]) in discogs_std
            and genre[1]>0] # make sure at least one "count" is present
    genres = [genre for genre in genres if not (genre[0] in seen or seen.add(genre[0]))]
        # if genre in seen, 2nd statement is not called, but that's ok because
        # we don't need to re-add it to the set
    # Now return, and echo message
    if len(genres)>0:
        genres, counts = zip(*genres) # see: https://stackoverflow.com/a/44157777/4970632
        genres_announce = [f"{genre} ({count:d})" for genre,count in zip(genres,counts)]
        print(f"MusicBrainz genres for writing: {', '.join(genres_announce)}.")
        return [*genres]
    else:
        print("No MusicBrainz genres found: couldn't find any useful recording tags.")
        return []

################################################################################
# Function to get "best" artwork from a release group
################################################################################
def guess_artwork(releases):
    """Gets album artwork. Note country is tricky; often japanese releases have 
    japenese text on them, but seems that European release are usually good and sometimes
    are the only available digital copies. Maybe just ignore asian countries?"""
    # First, go by release medium
    years = [int(release.get('date','0001')[:4]) for release in releases]
    filter_known = [False for release in releases] # want to catch any unknown media
    for m,medium in enumerate(media_pref):
        if medium=='other': # we are at the end; see if any media were left
            filter_ = [not known for known in filter_known] # iterate over what's left
        else: # filter, and add known media to lsit
            filter_ = [any(medium in _.get('format','xxxxx').lower() for _ in release.get('medium-list',[{}]))
                for release in releases] # last one is unknown
            filter_known = [f1 or f2 for f1,f2 in zip(filter_,filter_known)]
        releasesA = [r for f,r in zip(filter_,releases) if f]
        yearsA = [y for f,y in zip(filter_,years) if f]
        for year in sorted(set(yearsA), reverse=True):
            releasesB = [r for r,y in zip(releasesA,yearsA) if y==year]
            for country in anglo_countries:
                # Also try non-anglo countries (sometimes only one available)
                if country=='other':
                    releasesC = [r for r in releasesB if r.get('country','NA') not in anglo_countries]
                else:
                    releasesC = [r for r in releasesB if r.get('country','NA')==country]
                # Try to return image art; remaining releases, choose order at random
                for release in releasesC:
                    # User input
                    rmedia = [m.get('format','') for m in release.get('medium-list',[{}])]
                    rcountry, rtitle = release.get('country',''), release.get('title','')
                    print(f"Release candidate: name '{rtitle}', media '{', '.join(rmedia)}', "\
                        f"country '{rcountry}', year '{year}'.")
                    if not yesno():
                        continue
                    # Pull artwork
                    try: 
                        data = mb.get_image_front(release.get('id',''))
                    except ResponseError:
                        continue
                    # Manipulate
                    image = Image.open(BytesIO(data))
                    print(f"Image shape: {image.size[0]} x {image.size[1]}. Warping "\
                            "to square if not equal.")
                    if image.size[0]!=image.size[1]:
                        sqsize = min(image.size)
                        image = image.resize((sqsize,sqsize), Image.ANTIALIAS)
                        data = BytesIO()
                        image.save(data, format='JPEG')
                        data = data.getvalue()
                    return data

if __name__ == "__main__":
    ############################################################################
    # Parse all command-line arguments
    # Decided to make no-filtering by "words" the default, causes more trouble
    # than necessary! As long as we have the artist search we are fine.
    ############################################################################
    url = '' # by default, write nothing
    options = ['filter', 'genreonly', 'debug', 'noconfirm', 'noconfig']
    options = {option: False for option in options} # the default settings
    filepaths = []
    for arg in sys.argv[1:]:
        if arg.startswith('--'):
            if arg[2:5]=='url': # better than trying implicit search
                url = arg[2:].split('=')
                if len(url)==1:
                    raise ValueError("Invalid url argument.")
                url = ''.join(url[1:]) # re-combine after the first = sign
            elif arg[2:] not in options: # searches keys by default
                raise ValueError("Invalid '--' argument.")
            options[arg[2:]] = True # option enabled
        else:
            filepaths.append(arg)
    # filepath = ' '.join(filepath) # so don't have to escape spaces
    for filepath in filepaths: # instead require escapes and can loop through
        ########################################################################
        # Check existence of files and infer artist/track information
        ########################################################################
        if not os.path.exists(filepath):
            raise ValueError(f"Could not find file {filepath}.")
        filename = os.path.splitext(os.path.basename(filepath))[0].split(' - ')
        if len(filename)!=2:
            raise ValueError("Filename is not in the '<artist> - <title>' format.")
        artist, recording = filename # convert to artist and track

        ########################################################################
        # Open file, for different types
        # Currently have compatibility with MP4 and ID3 tags
        ########################################################################
        try: # read AAC info
            id3 = False # aac
            tags = MP4(filepath)
            print('Adding metadata according to AAC specifications.')
        except MP4StreamInfoError:
            id3 = True # mp3
            try: # check header presence
                tags = ID3(filepath)
                print('Adding metadata using the ID3 header.')
            except ID3NoHeaderError:
                raise ValueError("Format may be incorrect.")

        ########################################################################
        # Call functions and apply metadata
        ########################################################################
        print(f"Retrieving metadata for \"{artist} - {recording}\"...")
        artist, recordings = guess_recordings(artist, recording) # pull just the recordings
        albumprops = guess_album(recordings) # pull album year, artwork, and genres
        recording = recordings[0]['title'] # just use the first one
        # Special options for just tagging genres
        if options['genreonly']:
            print(f"Adding genres: '{albumprops['genres']}'")
            if id3:
                tags["TCON"] = TCON(text=albumprops['genres'][0], genres=albumprops['genres'])
                tags.save(filepath) # supply path, in case we are creating for first time
            if not id3:
                tags["\xa9gen"] = [*albumprops['genres']]
                tags.save()
            sys.exit()
        # Addd MP4-format metadata
        print(f"Adding metadata: MusicBrainz artwork, artist '{artist}', album "
            f"'{albumprops['title']}', year '{albumprops['year']}', "
            f"genres {'<none>' if len(albumprops['genres'])==0 else ', '.join(albumprops['genres'])}.")
        if id3: # First try editing an ID3 header, if has one
            # Below are ID3v2, not ID3v2.4 (default format of mutagen, and modern version)
            tags.delete(filepath) # delete old data, if we downloaded from somewhere; want to assigne my better data
            # General stuff
            tags["TPE1"] = TPE1(text=artist)
            tags["TIT2"] = TIT2(text=recording) # just track name
            tags["COMM"] = COMM(text=url, lang="eng", desc="URL")
            # Album stuff
            # tags["TYER"] = TYER(text=data['year']) # doesn't show up in swinsian, for some reason
            # tags["TORY"] = TORY(text=data['year']) # maybe this will
            # tags["TDAT"] = TDAT(text=data['year']) # recording date(s) (?)
            # tags["TRDA"] = TRDA(text='0101') # recording date, MMDD
            tags["TDOR"] = TDOR(text=albumprops['year']) # original release time
            tags["TDRC"] = TDRC(text=albumprops['year']) # recording time
            tags["TDRL"] = TDRL(text=albumprops['year']) # release time
            tags["TALB"] = TALB(text=albumprops['title']) # album
            tags["TOAL"] = TOAL(text=albumprops['title']) # original album
            if albumprops['image'] is not None:
                tags["APIC"] = APIC(data=albumprops['image'])
            if albumprops['genres'] is not None:
                tags["TCON"] = TCON(text=albumprops['genres'][0], genres=albumprops['genres'])
            tags.save(filepath) # supply path, in case we are creating ID3 header for first time
        if not id3: # Or just edit as an AAC file
            # General stuff
            tags["\xa9ART"] = [artist] # artist; includes whether "The" is in front, best punctuation, etc.
            tags["\xa9nam"] = [recording] # track name
            tags["\xa9cmt"] = [url] # embed URL as comment
            # Album stuff
            tags["\xa9day"] = [albumprops['year']]
            tags["\xa9alb"] = [albumprops['title']] # album, from lookup
            if albumprops['image'] is not None:
                tags["covr"] = [MP4Cover(albumprops['image'], imageformat=MP4Cover.FORMAT_JPEG)]
            if albumprops['genres'] is not None:
                tags["\xa9gen"] = [*albumprops['genres']] # genres
            tags.save() # don't need to re-supply with path

